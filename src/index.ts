import { gameToProcessName, gameToSteamId } from "./supportedGames";
import psList from "ps-list";
import { exec, fork } from "child_process";
import { app, autoUpdater, BrowserWindow, dialog, ipcMain, Menu, shell } from "electron";
import installExtension, { REACT_DEVELOPER_TOOLS, REDUX_DEVTOOLS } from "electron-extension-installer";
import fetch from "electron-fetch";
import isDev from "electron-is-dev";
import * as fs from "fs";
import { updateAvailable } from "gh-release-fetch";
import { version } from "../package.json";
import appData from "./appData";
import windowStateKeeper from "electron-window-state";
import * as nodePath from "path";
import { isMainThread } from "worker_threads";
import electronLog from "electron-log/main";
import i18n from "./configs/i18next.config";
import { globSync } from "glob";
import { windows, registerIpcMainListeners } from "./ipcMainListeners";

//-------------- HOT RELOAD DOESN'T RELOAD INDEX.TS

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const gotTheLock = app.requestSingleInstanceLock();

// let mainWindow: BrowserWindow | undefined;
// let viewerWindow: BrowserWindow | undefined;
// let skillsWindow: BrowserWindow | undefined;

if (!gotTheLock) {
  console.log("ONLY ONE INSTANCE ALLOWED!");
  app.quit();
} else {
  app.commandLine.appendSwitch("js-flags", "--max-old-space-size=12288");

  console.log("ARGVS:", process.argv);
  appData.startArgs = process.argv.slice(1);

  exec("NET SESSION", function (err, so, se) {
    appData.isAdmin = se.length === 0;
    console.log("isAdmin:", appData.isAdmin);
  });

  if (process.argv.find((arg) => arg == "-nogpu")) {
    console.log("DISABLED HARDWARE ACCELERATION");
    app.disableHardwareAcceleration();
  }

  process.noAsar = true;

  // Handle creating/removing shortcuts on Windows when installing/uninstalling.
  if (require("electron-squirrel-startup")) {
    // eslint-disable-line global-require
    app.quit();
  }

  if (isMainThread) {
    process.umask(0);

    electronLog.initialize({ preload: true });

    console.log = (...args) => {
      electronLog.info(...args);
    };
  }

  let checkWH3RunningInterval: NodeJS.Timer;

  const createWindow = (): void => {
    i18n.on("loaded", async () => {
      i18n.changeLanguage("en");
      i18n.off("loaded");

      console.log("I18 ON");
    });

    const mainWindowState = windowStateKeeper({
      file: "main_window.json",
      defaultWidth: 1280,
      defaultHeight: 900,
    });

    // Create the browser window.
    windows.mainWindow = new BrowserWindow({
      x: mainWindowState.x,
      y: mainWindowState.y,
      width: mainWindowState.width,
      height: mainWindowState.height,
      autoHideMenuBar: true,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#374151",
        symbolColor: "#9ca3af",
        height: 28,
      },
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
      title: "WH3 Mod Manager",
      icon: "./assets/modmanager.ico",
    });

    mainWindowState.manage(windows.mainWindow);

    // and load the index.html of the app.
    windows.mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    windows.mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: "deny" };
    });

    // const server = "https://hazel-neon-gamma.vercel.app";
    // const url = `${server}/update/${process.platform}/${app.getVersion()}`;

    // autoUpdater.setFeedURL({ url });
    // setInterval(() => {
    //   try {
    //     autoUpdater.checkForUpdates();
    //   } catch {}
    // }, 60000);
    // try {
    //   autoUpdater.checkForUpdates();
    // } catch {}

    // if (isDev) mainWindow?.webContents.openDevTools();

    if (isDev) {
      // no idea why but openDevTools is really uncooperative, this isn't great but it works
      setTimeout(() => {
        windows.mainWindow?.webContents.openDevTools({ mode: "right" });
      }, 25000);
    }

    autoUpdater.on("update-downloaded", (event, releaseNotes, releaseName) => {
      const dialogOpts = {
        type: "info" as const,
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? releaseNotes : releaseName,
        detail: "A new version has been downloaded. Restart the application to apply the updates.",
      };

      dialog.showMessageBox(dialogOpts).then((returnValue) => {
        if (returnValue.response === 0) autoUpdater.quitAndInstall();
      });
    });
    autoUpdater.on("error", (message) => {
      console.error("There was a problem updating the application");
      console.error(message);
    });

    windows.mainWindow.on("page-title-updated", (evt) => {
      evt.preventDefault();
    });

    windows.mainWindow.on("closed", () => {
      if (windows.viewerWindow) windows.viewerWindow.close();
      if (windows.skillsWindow) windows.skillsWindow.close();
    });

    const waitForModDownloads = async () => {
      if (appData.waitForModIds.length == 0) return;

      const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
      if (!contentFolder) return;

      const downloadsFolder = nodePath.join(contentFolder, "..", "..", "downloads");
      console.log("downloads folder:", downloadsFolder);

      if (globSync(`*${gameToSteamId[appData.currentGame]}*`, { cwd: downloadsFolder }).length != 0) {
        console.log("something for the current game is being downloaded!");
        return;
      }

      const toRemoveFromWaitForModIds: string[] = [];
      const idsToDownload: string[] = [];
      for (const modId of appData.waitForModIds) {
        console.log("checking", nodePath.join(contentFolder, modId));
        if (globSync("*.pack", { cwd: nodePath.join(contentFolder, modId) }).length == 0)
          idsToDownload.push(modId);
        else toRemoveFromWaitForModIds.push(modId);
      }

      fork(
        nodePath.join(__dirname, "sub.js"),
        [gameToSteamId[appData.currentGame], "download", idsToDownload.join(";")],
        {}
      );

      appData.waitForModIds = appData.waitForModIds.filter(
        (modId) => !toRemoveFromWaitForModIds.includes(modId)
      );
    };
    setInterval(waitForModDownloads, 3500);

    registerIpcMainListeners(windows.mainWindow, isDev);

    ipcMain.removeHandler("getUpdateData");
    ipcMain.handle("getUpdateData", async () => {
      if (isDev) return;

      let modUpdatedExists = { updateExists: false } as ModUpdateExists;

      const isAvailable = await updateAvailable("Shazbot/WH3-Mod-Manager", version);
      if (!isAvailable) return modUpdatedExists;

      await fetch(`https://api.github.com/repos/Shazbot/WH3-Mod-Manager/releases/latest`)
        .then((res) => res.json())
        .then((body) => {
          body.assets.forEach((asset: { content_type: string; browser_download_url: string }) => {
            windows.mainWindow?.webContents.send(
              "handleLog",
              asset.content_type == "application/x-zip-compressed"
            );
            if (asset.content_type === "application/x-zip-compressed") {
              modUpdatedExists = {
                updateExists: true,
                downloadURL: asset.browser_download_url,
              } as ModUpdateExists;
            }
          });

          if (body.html_url) modUpdatedExists.releaseNotesURL = body.html_url;
        })
        .catch();

      return modUpdatedExists;
    });

    ipcMain.on("sendApiExists", async () => {
      windows.mainWindow?.webContents.send("handleLog", "API now exists");
      windows.mainWindow?.webContents.send("setIsDev", isDev);
      windows.mainWindow?.webContents.send("setStartArgs", appData.startArgs);
      windows.mainWindow?.webContents.send("setIsAdmin", appData.isAdmin);

      try {
        const localesPath = isDev ? "./locales/" : "./resources/app/.webpack/main/locales";
        const availableLocalizations = (await fs.readdirSync(localesPath, { withFileTypes: true }))
          .filter((dirent) => dirent.isDirectory())
          .map((dirent) => dirent.name);

        windows.mainWindow?.webContents.send("setAvailableLanguages", availableLocalizations);
        // eslint-disable-next-line no-empty
      } catch (e) {}

      if (!checkWH3RunningInterval) {
        checkWH3RunningInterval = setInterval(async () => {
          try {
            const processes = await psList();
            const isWH3Running = processes.some(
              (process) => process.name == gameToProcessName[appData.currentGame]
            );
            if (appData.isWH3Running != isWH3Running) {
              appData.isWH3Running = isWH3Running;
              windows.mainWindow?.webContents.send("setIsWH3Running", appData.isWH3Running);
            }
          } catch (e) {
            console.log("psList coroutine error:", e);
          }
        }, 500);
      }
    });
  };

  app.on("second-instance", () => {
    // Someone tried to run a second instance, we should focus our window.
    if (windows.mainWindow) {
      if (windows.mainWindow.isMinimized()) windows.mainWindow.restore();
      windows.mainWindow.focus();
    }
  });

  // not using a default menu
  Menu.setApplicationMenu(null);

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on("ready", createWindow);

  app.whenReady().then(() => {
    installExtension(REACT_DEVELOPER_TOOLS, {
      loadExtensionOptions: {
        allowFileAccess: true,
      },
    })
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));

    installExtension(REDUX_DEVTOOLS, {
      loadExtensionOptions: {
        allowFileAccess: true,
      },
    })
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));
  });

  // Quit when all windows are closed, except on macOS. There, it's common
  // for applications and their menu bar to stay active until the user quits
  // explicitly with Cmd + Q.
  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });

  process.on("unhandledRejection", (err) => {
    console.log(err);
  });
  process.on("uncaughtException", (err) => {
    console.log(err);
  });
}
