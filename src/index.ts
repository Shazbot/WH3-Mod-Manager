import debounce from "just-debounce-it";
import { AmendedSchemaField, Pack, PackCollisions, SCHEMA_FIELD_TYPE, SchemaField } from "./packFileTypes";
import { execFile, exec, fork } from "child_process";
import { app, autoUpdater, BrowserWindow, clipboard, dialog, ipcMain, shell } from "electron";
import installExtension, { REDUX_DEVTOOLS } from "electron-devtools-installer";
import fetch from "electron-fetch";
import isDev from "electron-is-dev";
import * as fs from "fs/promises";
import * as fsdumb from "fs";
import { updateAvailable } from "gh-release-fetch";
import { version } from "../package.json";
import { sortByNameAndLoadOrder } from "./modSortingHelpers";
import { readAppConfig, setStartingAppState, writeAppConfig } from "./appConfigFunctions";
import { fetchModData, getContentModInFolder, getDataMod, getFolderPaths, getMods } from "./modFunctions";
import appData, { AppFolderPaths } from "./appData";
import chokidar from "chokidar";
import { getSaveFiles, setupSavesWatcher } from "./gameSaves";
import windowStateKeeper from "electron-window-state";
import { readPackHeader } from "./packFileHandler";
import {
  addFakeUpdate,
  getPacksInSave,
  mergeMods,
  readPack,
  writePack,
  getDBVersion,
  readFromExistingPack,
} from "./packFileSerializer";
import * as nodePath from "path";
import { format } from "date-fns";
import {
  appendPackFileCollisions,
  appendPackTableCollisions,
  removeFromPackFileCollisions,
  removeFromPackTableCollisions,
} from "./readPacksWorker";
import { isMainThread } from "worker_threads";
import electronLog from "electron-log";
import * as fsExtra from "fs-extra";
import { getCompatData } from "./packFileDataManager";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VIEWER_WEBPACK_ENTRY: string;
declare const VIEWER_PRELOAD_WEBPACK_ENTRY: string;

const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  app.quit();
} else {
  process.noAsar = true;

  // Handle creating/removing shortcuts on Windows when installing/uninstalling.
  if (require("electron-squirrel-startup")) {
    // eslint-disable-line global-require
    app.quit();
  }

  if (isMainThread) {
    process.umask(0);

    console.log = (...args) => {
      electronLog.info(...args);
    };
  }

  let mainWindow: BrowserWindow | undefined;
  let viewerWindow: BrowserWindow | undefined;
  let contentWatcher: chokidar.FSWatcher | undefined;
  let dataWatcher: chokidar.FSWatcher | undefined;
  let downloadsWatcher: chokidar.FSWatcher | undefined;
  let mergedWatcher: chokidar.FSWatcher | undefined;
  let queuedViewerData: (PackViewData | undefined)[];
  let isViewerReady = false;

  const tempModDatas: ModData[] = [];
  const sendModData = debounce(() => {
    mainWindow?.webContents.send("setModData", [...tempModDatas]);
    tempModDatas.splice(0, tempModDatas.length);
  }, 200);

  const readConfig = async (): Promise<AppStateToWrite> => {
    try {
      const appState = await readAppConfig();
      if (!appData.hasReadConfig) {
        fork(nodePath.join(__dirname, "sub.js"), ["justRun"], {}); // forces steam workshop to download mods
        setStartingAppState(appState);
      }

      if (appState.appFolderPaths) {
        if (
          appState.appFolderPaths.contentFolder &&
          !fsdumb.existsSync(appState.appFolderPaths.contentFolder)
        ) {
          appState.appFolderPaths.contentFolder = "";
        } else {
          appData.contentFolder = appState.appFolderPaths.contentFolder;
        }

        if (appState.appFolderPaths.gamePath && !fsdumb.existsSync(appState.appFolderPaths.gamePath)) {
          appState.appFolderPaths.gamePath = "";
        } else {
          appData.gamePath = appState.appFolderPaths.gamePath;
          appData.dataFolder = nodePath.join(appState.appFolderPaths.gamePath, "/data/");
        }
      }

      return appState;
    } finally {
      appData.hasReadConfig = true;
    }
  };

  const log = (msg: string) => {
    mainWindow?.webContents.send("handleLog", msg);
    console.log(msg);
  };

  const removeMod = async (mainWindow: BrowserWindow, modPath: string) => {
    mainWindow?.webContents.send("removeMod", modPath);
  };

  const getMod = async (mainWindow: BrowserWindow, modPath: string) => {
    let mod: Mod | undefined;
    try {
      if (modPath.includes("\\content\\1142710\\")) {
        const modSubfolderName = nodePath.dirname(modPath).replace(/.*\\/, "");
        console.log("looking for ", modSubfolderName);
        mod = await getContentModInFolder(modSubfolderName, log);
      } else {
        console.log("looking for DATA MOD: ", modPath);
        mod = await getDataMod(modPath, log);
      }
    } catch (e) {
      console.log(e);
    }

    return mod;
  };

  const appendPacksData = (newPack: Pack) => {
    const existingPack = appData.packsData.find((pack) => pack.path == newPack.path);

    if (!existingPack) {
      appData.packsData.push(newPack);
      mainWindow?.webContents.send("setPacksDataRead", [newPack.path]);

      if (appData.dataPack && newPack != appData.dataPack) {
        const overwrittenFileNames = newPack.packedFiles
          .map((packedFile) => packedFile.name)
          .filter(
            (packedFileName) => packedFileName.match(/db\\.*\\data__/) || packedFileName.endsWith(".lua")
          )
          .filter((packedFileName) =>
            appData.dataPack?.packedFiles.some((packedFileInData) => packedFileInData.name == packedFileName)
          );
        if (overwrittenFileNames.length > 0) {
          appData.overwrittenDataPackedFiles[newPack.name] = overwrittenFileNames;
          mainWindow?.webContents.send("setOverwrittenDataPackedFiles", appData.overwrittenDataPackedFiles);
        }
      }
    } else {
      console.log("existing pack for", newPack.name, "found");
      newPack.packedFiles
        .filter((packedFile) => packedFile.schemaFields)
        .forEach((newPackedFile) => {
          const index = existingPack.packedFiles.findIndex(
            (existingPackedFile) => existingPackedFile.name == newPackedFile.name
          );
          if (index != -1) {
            existingPack.packedFiles.splice(index, 1);
          }
          existingPack.packedFiles.push(newPackedFile);
        });
    }
  };

  const appendCollisions = async (newPack: Pack) => {
    while (!appData.compatData) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    if (appData.compatData) {
      appData.compatData.packTableCollisions = appendPackTableCollisions(
        appData.packsData,
        appData.compatData.packTableCollisions,
        newPack
      );
      appData.compatData.packFileCollisions = appendPackFileCollisions(
        appData.packsData,
        appData.compatData.packFileCollisions,
        newPack
      );
    }
  };

  const onNewPackFound = async (path: string) => {
    if (!mainWindow) return;
    mainWindow.webContents.send("handleLog", "MOD ADDED: " + path);
    console.log("MOD ADDED: " + path);

    const mod = await getMod(mainWindow, path);
    if (mod) {
      mainWindow?.webContents.send("addMod", mod);
    }
  };
  const onPackDeleted = async (path: string) => {
    if (!mainWindow) return;
    mainWindow.webContents.send("handleLog", "MOD REMOVED: " + path);
    console.log("MOD REMOVED: " + path);
    await removeMod(mainWindow, path);

    if (appData.packsData && appData.packsData.some((pack) => pack.path == path)) {
      appData.packsData = appData.packsData.filter((pack) => pack.path != path);
    }

    removePackFromCollisions(path);
  };

  const removePackFromCollisions = (packPath: string) => {
    if (appData.compatData) {
      appData.compatData.packTableCollisions = removeFromPackTableCollisions(
        appData.compatData.packTableCollisions,
        nodePath.basename(packPath)
      );
      appData.compatData.packFileCollisions = removeFromPackFileCollisions(
        appData.compatData.packFileCollisions,
        nodePath.basename(packPath)
      );
    }
  };

  const getAllMods = async () => {
    try {
      const mods = await getMods(log);
      mainWindow?.webContents.send("modsPopulated", mods);

      mods.forEach(async (mod) => {
        try {
          if (mod == null || mod.path == null) {
            console.error("MOD OR MOD PATH IS NULL");
          }
          const packHeaderData = await readPackHeader(mod.path);
          if (packHeaderData.isMovie || packHeaderData.dependencyPacks.length > 0)
            mainWindow?.webContents.send("setPackHeaderData", packHeaderData);
        } catch (e) {
          if (e instanceof Error) {
            log(e.message);
          }
        }
      });

      if (!appData.saveSetupDone) {
        appData.saveSetupDone = true;
        getSaveFiles()
          .then((saves) => {
            setupSavesWatcher((saves) => mainWindow?.webContents.send("savesPopulated", saves));
            mainWindow?.webContents.send("savesPopulated", saves);
          })
          .catch();
      }

      if (appData.dataFolder) {
        const dataPackPath = nodePath.join(appData.dataFolder, "data.pack");
        const dataMod: Mod = {
          humanName: "",
          name: "data.pack",
          path: dataPackPath,
          imgPath: "",
          workshopId: "",
          isEnabled: true,
          modDirectory: `${appData.dataFolder}`,
          isInData: true,
          lastChanged: undefined,
          loadOrder: undefined,
          author: "",
          isDeleted: false,
          isMovie: false,
          size: 0,
        };
        if (appData.packsData.every((iterPack) => iterPack.path != dataPackPath)) {
          console.log("READING DATA PACK");
          appData.currentlyReadingModPaths.push(dataPackPath);
          const dataPackData = await readPack(dataMod.path, {
            // tablesToRead: ["db\\units_custom_battle_permissions_tables\\"],
            skipParsingTables: true,
          });
          appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
            (path) => path != dataPackPath
          );
          if (dataPackData) {
            appData.dataPack = dataPackData;

            try {
              const res = await fetch(
                `https://raw.githubusercontent.com/Shazbot/WH3-Mod-Manager/tw_updates/tw_updates/wh3.json`
              );
              const gameUpdates = (await res.json()) as GameUpdateData[];
              gameUpdates.sort((a, b) => parseInt(b.timestamp) - parseInt(a.timestamp));

              if (gameUpdates[0]) {
                mainWindow?.webContents.send(
                  "setDataModLastChangedLocal",
                  parseInt(gameUpdates[0].timestamp) * 1000
                );
              }
            } catch {
              /* empty */
            }
          }
          if (appData.packsData.every((iterPack) => iterPack.path != dataPackData.path)) {
            appendPacksData(dataPackData);
          }
        }
      }

      try {
        fork(
          nodePath.join(__dirname, "sub.js"),
          [
            "checkState",
            mods
              .filter(
                (mod) => !mod.isInData && !isNaN(Number(mod.workshopId)) && !isNaN(parseFloat(mod.workshopId))
              )
              .map((mod) => mod.workshopId)
              .join(";"),
          ],
          {}
        );
      } catch (e) {
        console.log(e);
      }
    } catch (err) {
      console.log(err);
    }

    if (isDev) {
      await contentWatcher?.close();
      await dataWatcher?.close();
      await downloadsWatcher?.close();
      await mergedWatcher?.close();
    }
    if (!appData.contentFolder || !appData.dataFolder || !appData.gamePath) return;

    if (!contentWatcher || isDev) {
      const contentFolder = appData.contentFolder.replaceAll("\\", "/").replaceAll("//", "/");
      console.log("content folder:", contentFolder);
      contentWatcher = chokidar
        .watch(`${contentFolder}/**/*.pack`, {
          ignoreInitial: true,
          ignored: /whmm_backups/,
        })
        .on("add", async (path) => {
          console.log("NEW CONTENT ADD", path);
          onNewPackFound(path);
        })
        .on("unlink", async (path) => {
          console.log("NEW CONTENT UNLINK", path);
          onPackDeleted(path);
        });
    }
    if (!downloadsWatcher || isDev) {
      const downloadsFolder = appData.contentFolder
        .replaceAll("\\", "/")
        .replaceAll("//", "/")
        .replace("/content/", "/downloads/");
      console.log("downloads folder:", downloadsFolder);
      downloadsWatcher = chokidar
        .watch(`${downloadsFolder}/**/*.pack`, {
          ignoreInitial: true,
          awaitWriteFinish: true,
          ignored: /whmm_backups/,
        })
        .on("add", async (path) => {
          console.log("NEW DOWNLOADS ADD", path);
          fork(nodePath.join(__dirname, "sub.js"), ["justRun"], {});
        })
        .on("unlink", async (path) => {
          console.log("NEW DOWNLOADS UNLINK", path);
        });
    }
    if (!dataWatcher || isDev) {
      const dataFolder = appData.dataFolder.replaceAll("\\", "/").replaceAll("//", "/");
      dataWatcher = chokidar
        .watch([`${dataFolder}/*.pack`], {
          ignoreInitial: true,
          awaitWriteFinish: true,
          ignored: /whmm_backups/,
        })
        .on("add", async (path) => {
          onNewPackFound(path);
        })
        .on("unlink", async (path) => {
          onPackDeleted(path);
        })
        .on("change", async (path) => {
          onPackDeleted(path);
          onNewPackFound(path);
        });
    }
    if (!mergedWatcher || isDev) {
      const mergedDirPath = nodePath.join(appData.gamePath, "/merged/");
      exec(`mkdir "${mergedDirPath}"`);

      while (!fsExtra.existsSync(mergedDirPath)) {
        await new Promise((resolve) => {
          setTimeout(resolve, 100);
        });
      }

      // await fsExtra.ensureDir(nodePath.join(appData.gamePath, "/merged/"));
      const gamePath = appData.gamePath.replaceAll("\\", "/").replaceAll("//", "/");
      mergedWatcher = chokidar
        .watch([`${gamePath}/merged/*.pack`], {
          ignoreInitial: false,
          awaitWriteFinish: {
            stabilityThreshold: 3000,
            pollInterval: 100,
          },
          ignored: /whmm_backups/,
          usePolling: true,
        })
        .on("add", async (path) => {
          onNewPackFound(path);
        })
        .on("unlink", async (path) => {
          onPackDeleted(path);
        })
        .on("change", async (path) => {
          onPackDeleted(path);
          onNewPackFound(path);
        });
    }
  };

  const createWindow = (): void => {
    const mainWindowState = windowStateKeeper({
      file: "main_window.json",
      defaultWidth: 1280,
      defaultHeight: 900,
    });

    // Create the browser window.
    mainWindow = new BrowserWindow({
      x: mainWindowState.x,
      y: mainWindowState.y,
      width: mainWindowState.width,
      height: mainWindowState.height,
      autoHideMenuBar: true,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#374151",
        symbolColor: "#9ca3af",
        height: 28,
      },
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
      title: "WH3 Mod Manager",
    });

    mainWindowState.manage(mainWindow);

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: "deny" };
    });

    // Open the DevTools.
    if (isDev) {
      mainWindow.webContents.openDevTools();
    }

    // const server = "https://hazel-neon-gamma.vercel.app";
    // const url = `${server}/update/${process.platform}/${app.getVersion()}`;

    // autoUpdater.setFeedURL({ url });
    // setInterval(() => {
    //   try {
    //     autoUpdater.checkForUpdates();
    //   } catch {}
    // }, 60000);
    // try {
    //   autoUpdater.checkForUpdates();
    // } catch {}

    autoUpdater.on("update-downloaded", (event, releaseNotes, releaseName) => {
      const dialogOpts = {
        type: "info",
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? releaseNotes : releaseName,
        detail: "A new version has been downloaded. Restart the application to apply the updates.",
      };

      dialog.showMessageBox(dialogOpts).then((returnValue) => {
        if (returnValue.response === 0) autoUpdater.quitAndInstall();
      });
    });
    autoUpdater.on("error", (message) => {
      console.error("There was a problem updating the application");
      console.error(message);
    });

    mainWindow.on("page-title-updated", (evt) => {
      evt.preventDefault();
    });

    mainWindow.on("closed", () => {
      if (viewerWindow) viewerWindow.close();
    });

    ipcMain.on("getAllModData", (event, ids: string[]) => {
      if (isDev) return;

      fetchModData(
        ids.filter((id) => id !== ""),
        (modData) => {
          tempModDatas.push(modData);
          sendModData();
        },
        (msg) => {
          mainWindow?.webContents.send("handleLog", msg);
          console.log(msg);
        }
      );
    });

    ipcMain.on("getPacksInSave", async (event, saveName: string) => {
      mainWindow?.webContents.send("packsInSave", await getPacksInSave(saveName));
    });

    ipcMain.on("readAppConfig", async () => {
      try {
        try {
          const appState = await readConfig();
          mainWindow?.webContents.send("fromAppConfig", appState);
        } catch (err) {
          mainWindow?.webContents.send("failedReadingConfig");
          console.log(err);
        }

        if (!appData.gamePath || !appData.contentFolder || !appData.dataFolder) {
          await getFolderPaths(log);
        }

        getAllMods();
      } finally {
        mainWindow?.webContents.send("setAppFolderPaths", {
          gamePath: appData.gamePath || "",
          contentFolder: appData.contentFolder || "",
        } as AppFolderPaths);
      }
    });

    const refreshModsIfFoldersValid = () => {
      if (appData.contentFolder && appData.gamePath && appData.dataFolder) {
        console.log(appData.contentFolder, appData.gamePath, appData.dataFolder);
        getAllMods();
      }
    };

    ipcMain.on("selectContentFolder", async () => {
      try {
        if (!mainWindow) return;
        const dialogReturnValue = await dialog.showOpenDialog(mainWindow, {
          properties: ["openDirectory"],
        });

        if (!dialogReturnValue.canceled) {
          const contentFolderPath = dialogReturnValue.filePaths[0];
          appData.contentFolder = contentFolderPath;
          mainWindow?.webContents.send("setContentFolder", contentFolderPath);
          refreshModsIfFoldersValid();
        }
      } catch (e) {
        console.log(e);
      }
    });

    ipcMain.on("selectWarhammer3Folder", async () => {
      try {
        if (!mainWindow) return;
        const dialogReturnValue = await dialog.showOpenDialog(mainWindow, {
          properties: ["openDirectory"],
        });

        if (!dialogReturnValue.canceled) {
          const wh3FolderPath = dialogReturnValue.filePaths[0];
          appData.gamePath = wh3FolderPath;
          appData.dataFolder = nodePath.join(wh3FolderPath, "/data/");
          mainWindow?.webContents.send("setWarhammer3Folder", wh3FolderPath);

          const calculatedContentPath = nodePath.join(
            appData.gamePath,
            "..",
            "..",
            "workshop",
            "content",
            "1142710"
          );
          if (fsdumb.existsSync(calculatedContentPath)) {
            appData.contentFolder = calculatedContentPath;
            mainWindow?.webContents.send("setContentFolder", calculatedContentPath);
          }
          refreshModsIfFoldersValid();
        }
      } catch (e) {
        console.log(e);
      }
    });

    ipcMain.on("getCompatData", async (event, mods: Mod[]) => {
      console.log("SET PACK COLLISIONS");

      await readMods(mods, false, true);
      // if (pathsToUse) {
      mainWindow?.webContents.send(
        "setPackCollisions",
        getCompatData(appData.packsData.filter((pack) => mods.some((mod) => mod.path == pack.path)))
      );
      // } else {
      //   mainWindow?.webContents.send("setPackCollisions", getCompatData(appData.packsData));
      // }
      // mainWindow?.webContents.send("setPackCollisions", {
      // packFileCollisions: appData.compatData.packFileCollisions,
      // packTableCollisions: appData.compatData.packTableCollisions,
      // } as PackCollisions);
    });

    ipcMain.on("copyToData", async (event, modPathsToCopy?: string[]) => {
      const mods = await getMods(log);
      let withoutDataMods = mods.filter((mod) => !mod.isInData);
      if (modPathsToCopy) {
        withoutDataMods = withoutDataMods.filter((mod) =>
          modPathsToCopy.some((modPathToCopy) => modPathToCopy == mod.path)
        );
      }
      const copyPromises = withoutDataMods.map((mod) => {
        mainWindow?.webContents.send(
          "handleLog",
          `COPYING ${mod.path} to ${appData.gamePath}\\data\\${mod.name}`
        );

        return fs.copyFile(mod.path, `${appData.gamePath}\\data\\${mod.name}`);
      });

      await Promise.allSettled(copyPromises);
      getAllMods();
    });

    ipcMain.on("cleanData", async () => {
      const mods = await getMods(log);
      mods.forEach((mod) => {
        if (mod.isInData) mainWindow?.webContents.send("handleLog", `is in data ${mod.name}`);
      });
      const modsInBothPlaces = mods.filter(
        (mod) => mod.isInData && mods.find((modSecond) => !modSecond.isInData && modSecond.name === mod.name)
      );
      const deletePromises = modsInBothPlaces.map((mod) => {
        mainWindow?.webContents.send("handleLog", `DELETING ${mod.path}`);

        return fs.unlink(mod.path);
      });

      await Promise.allSettled(deletePromises);
      getAllMods();
    });

    ipcMain.on("saveConfig", (event, data: AppState) => {
      const enabledMods = data.currentPreset.mods.filter(
        (iterMod) => iterMod.isEnabled || data.alwaysEnabledMods.find((mod) => mod.name === iterMod.name)
      );
      const hiddenAndEnabledMods = data.hiddenMods.filter((iterMod) =>
        enabledMods.find((mod) => mod.name === iterMod.name)
      );
      mainWindow?.setTitle(
        `WH3 Mod Manager v${version}: ${enabledMods.length} mods enabled` +
          (hiddenAndEnabledMods.length > 0 ? ` (${hiddenAndEnabledMods.length} of those hidden)` : "")
      );
      writeAppConfig(data);
    });

    const isSchemaFieldNumber = (fieldType: SCHEMA_FIELD_TYPE) => {
      return fieldType === "I32" || fieldType === "I64" || fieldType === "F32" || fieldType === "F64";
    };

    const getPackViewData = (pack: Pack, table?: DBTable) => {
      const tables = pack.packedFiles.map((packedFile) => packedFile.name);
      const result = { packName: pack.name, packPath: pack.path, tables } as PackViewData;
      if (table) {
        const packedFile = pack.packedFiles.find((packedFile) =>
          packedFile.name.endsWith(`\\${table.dbName}\\${table.dbSubname}`)
        );
        if (packedFile) {
          const amendedSchemaFields: AmendedSchemaField[] = [];
          const dbversion = getDBVersion(packedFile);
          if (!dbversion) {
            return;
          }

          const chunkedSchemaIntoRows =
            packedFile.schemaFields?.reduce<SchemaField[][]>((resultArray, item, index) => {
              const chunkIndex = Math.floor(index / dbversion.fields.length);

              if (!resultArray[chunkIndex]) {
                resultArray[chunkIndex] = []; // start a new chunk
              }

              resultArray[chunkIndex].push(item as SchemaField);

              return resultArray;
            }, []) ?? [];

          // console.log("chunked into ", chunkedSchemaIntoRows.length);
          // console.log("num fields in row is ", dbversion.fields.length);
          // console.log("db types are ", dbversion.fields.map((field) => field.name).join(", "));
          // console.log("with num chunks of ", chunkedSchemaIntoRows.map((row) => row.length).join(","));

          for (const chunkedSchemaIntoRow of chunkedSchemaIntoRows) {
            for (const dbFieldsIndex of dbversion.fields.keys()) {
              const { name, field_type } = dbversion.fields[dbFieldsIndex];
              const fields = chunkedSchemaIntoRow[dbFieldsIndex].fields;
              if (!fields) {
                console.log("MISSING FIELD ", name);
              }
              const resolvedKeyValue = isSchemaFieldNumber(field_type)
                ? (fields[0].val as number).toFixed(3).toString()
                : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  (fields[1] && fields[1].val!.toString()) || fields[0].val!.toString();

              amendedSchemaFields.push({ name, resolvedKeyValue, ...chunkedSchemaIntoRow[dbFieldsIndex] });

              // if (chunkedSchemaIntoRow == chunkedSchemaIntoRows[0]) {
              //   console.log("AMENDING ", name, resolvedKeyValue);
              // }
            }
          }
          packedFile.schemaFields = amendedSchemaFields;
          result.currentTableSchema = dbversion;
        }
        result.currentTable = packedFile;
      }

      return result;
    };

    const dbTableToString = (dbTable: DBTable) => {
      return `db\\${dbTable.dbName}\\${dbTable.dbSubname}`;
    };

    const getPackData = async (packPath: string, table?: DBTable) => {
      console.log(`getPackData ${packPath}`);
      if (table) console.log("GETTING TABLE ", table.dbName, table.dbSubname);
      if (packPath == "data.pack" || nodePath.basename(packPath) == "data.pack") {
        if (!appData.dataFolder) {
          console.log("WAIT FOR DATAFOLDER TO BE SET");
          await new Promise((resolve) => setTimeout(resolve, 1000));
          console.log("DONE WAITING FOR DATAFOLDER");
          getPackData(packPath, table);
          return;
        }
        if (packPath == "data.pack") {
          console.log("data folder is", appData.dataFolder);
          packPath = nodePath.join(appData.dataFolder as string, "data.pack");
        }
      }
      console.log("CURRENTLY READING:");
      console.log(appData.currentlyReadingModPaths);

      const packData = appData.packsData.find((pack) => pack.path === packPath);
      if (
        appData.currentlyReadingModPaths.every((path) => path != packPath) &&
        (!packData ||
          (table &&
            packData.packedFiles
              .filter((packedFile) => packedFile.schemaFields)
              .every((packedFile) => packedFile.name != dbTableToString(table))))
      ) {
        appData.currentlyReadingModPaths.push(packPath);
        console.log(`READING ${packPath}`);
        const newPack = await readPack(packPath, table && { tablesToRead: [dbTableToString(table)] });
        appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
          (path) => path != packPath
        );
        if (appData.packsData.every((pack) => pack.path != packPath)) {
          appendPacksData(newPack);
        }

        const toSend = [getPackViewData(newPack, table)];
        viewerWindow?.webContents.send("setPacksData", toSend);
        if (!isViewerReady) {
          console.log("VIEWER NOT READY, QUEUEING");
          queuedViewerData = toSend;
        }
      } else {
        if (appData.currentlyReadingModPaths.some((path) => path == packPath)) {
          console.log("WAIT");
          await new Promise((resolve) => setTimeout(resolve, 1000));
          console.log("DONE WAITING");
          getPackData(packPath, table);
          return;
        }
        const packData = appData.packsData.find((pack) => pack.path === packPath);

        if (packData) {
          const toSend = [getPackViewData(packData, table)];

          viewerWindow?.webContents.send("setPacksData", toSend);
          if (!isViewerReady) {
            console.log("VIEWER NOT READY, QUEUEING");
            queuedViewerData = toSend;
          }
        }
      }
    };

    ipcMain.on("getPackData", async (event, packPath: string, table?: DBTable) => {
      getPackData(packPath, table);
    });

    ipcMain.on("requestOpenModInViewer", (event, modPath: string) => {
      if (modPath == "data.pack") {
        modPath = nodePath.join(appData.dataFolder as string, "data.pack");
      }
      console.log("ON requestOpenModInViewer", modPath);
      viewerWindow?.webContents.send("openModInViewer", modPath);
      getPackData(modPath);
      if (viewerWindow) {
        viewerWindow.focus();
      } else {
        createViewerWindow();
      }
    });

    const readMods = async (mods: Mod[], skipParsingTables = true, skipCollisionCheck = true) => {
      if (!skipParsingTables) {
        appData.packsData = appData.packsData.filter((pack) => !mods.some((mod) => mod.path == pack.path));
      }
      for (const mod of mods) {
        if (
          appData.currentlyReadingModPaths.every((path) => path != mod.path) &&
          appData.packsData.every((pack) => pack.path != mod.path)
        ) {
          console.log("READING " + mod.name);
          appData.currentlyReadingModPaths.push(mod.path);
          const newPack = await readPack(mod.path, {
            skipParsingTables: skipParsingTables,
          });
          appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
            (path) => path != mod.path
          );
          if (appData.packsData.every((pack) => pack.path != mod.path)) {
            appendPacksData(newPack);
          }
          if (!skipCollisionCheck) {
            appendCollisions(newPack);
          }
        }
      }

      if (!skipCollisionCheck) {
        mainWindow?.webContents.send("setPackCollisions", {
          packFileCollisions: appData.compatData.packFileCollisions,
          packTableCollisions: appData.compatData.packTableCollisions,
        } as PackCollisions);
      }
    };

    ipcMain.on("readMods", (event, mods: Mod[], skipCollisionCheck = true) => {
      console.log(
        "READ MODS RECEIVED",
        mods.map((mod) => mod.name)
      );
      readMods(mods, skipCollisionCheck, skipCollisionCheck);
    });

    ipcMain.removeHandler("getUpdateData");
    ipcMain.handle("getUpdateData", async () => {
      if (isDev) return;

      let modUpdatedExists = { updateExists: false } as ModUpdateExists;

      const isAvailable = await updateAvailable("Shazbot/WH3-Mod-Manager", version);
      if (!isAvailable) return modUpdatedExists;

      await fetch(`https://api.github.com/repos/Shazbot/WH3-Mod-Manager/releases/latest`)
        .then((res) => res.json())
        .then((body) => {
          body.assets.forEach((asset: { content_type: string; browser_download_url: string }) => {
            mainWindow?.webContents.send("handleLog", asset.content_type == "application/x-zip-compressed");
            if (asset.content_type === "application/x-zip-compressed") {
              modUpdatedExists = {
                updateExists: true,
                downloadURL: asset.browser_download_url,
              } as ModUpdateExists;
            }
          });
        })
        .catch();

      return modUpdatedExists;
    });

    ipcMain.on("sendApiExists", async () => {
      mainWindow?.webContents.send("handleLog", "API now exists");
      mainWindow?.webContents.send("setIsDev", isDev);
    });
  };

  const createViewerWindow = () => {
    if (viewerWindow) return;

    const viewerWindowState = windowStateKeeper({
      file: "viewer_window.json",
      defaultWidth: 1280,
      defaultHeight: 900,
    });

    viewerWindow = new BrowserWindow({
      x: viewerWindowState.x,
      y: viewerWindowState.y,
      width: viewerWindowState.width,
      height: viewerWindowState.height,
      autoHideMenuBar: true,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#374151",
        symbolColor: "#9ca3af",
        height: 28,
      },
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        preload: VIEWER_PRELOAD_WEBPACK_ENTRY,
      },
      title: "WH3 Mod Manager Mod Viewer",
    });

    viewerWindowState.manage(viewerWindow);

    viewerWindow.loadURL(VIEWER_WEBPACK_ENTRY);

    viewerWindow.on("page-title-updated", (evt) => {
      evt.preventDefault();
    });

    viewerWindow.on("closed", () => {
      viewerWindow = undefined;
      isViewerReady = false;
    });
  };

  app.on("second-instance", () => {
    // Someone tried to run a second instance, we should focus our window.
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on("ready", createWindow);

  app.whenReady().then(() => {
    installExtension(REDUX_DEVTOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));
  });

  // Quit when all windows are closed, except on macOS. There, it's common
  // for applications and their menu bar to stay active until the user quits
  // explicitly with Cmd + Q.
  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });

  process.on("unhandledRejection", (err) => {
    console.log(err);
  });
  process.on("uncaughtException", (err) => {
    console.log(err);
  });

  const sendQueuedDataToViewer = async () => {
    if (!isViewerReady) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      sendQueuedDataToViewer();
      return;
    }

    console.log("SENDING QUEUED DATA TO VIEWER");
    viewerWindow?.webContents.send("setPacksData", queuedViewerData);
    viewerWindow?.webContents.send("openModInViewer", queuedViewerData[0]?.packPath);
    viewerWindow?.focus();
    queuedViewerData = [];
  };

  ipcMain.on("viewerIsReady", (event) => {
    console.log("VIEWER IS NOW READY");
    isViewerReady = true;

    // console.log("QUEUED DATA IS ", queuedViewerData);
    if (queuedViewerData.length > 0) {
      sendQueuedDataToViewer();
    }
  });

  ipcMain.on("openFolderInExplorer", (event, path: string) => {
    shell.showItemInFolder(path);
  });

  ipcMain.on("openInSteam", (event, url: string) => {
    exec(`start steam://openurl/${url}`);
  });

  ipcMain.on("openPack", (event, path: string) => {
    shell.openPath(path);
  });
  ipcMain.on("putPathInClipboard", (event, path: string) => {
    clipboard.writeText(path);
  });
  ipcMain.on("updateMod", async (event, mod: Mod, contentMod: Mod) => {
    const uploadFolderName = contentMod.workshopId;
    const uploadFolderPath = nodePath.join(nodePath.dirname(mod.path), "whmm_uploads_" + uploadFolderName);

    await fs.rm(uploadFolderPath, { recursive: true, force: true });
    await fs.mkdir(uploadFolderPath, { recursive: true });

    await fs.link(mod.path, nodePath.join(uploadFolderPath, mod.name));
    await fs.link(mod.imgPath, nodePath.join(uploadFolderPath, nodePath.basename(mod.imgPath)));

    const child = fork(
      nodePath.join(__dirname, "sub.js"),
      ["update", contentMod.workshopId, uploadFolderPath],
      {}
    );
    child.on("message", (folderPath: string) => {
      console.log("child says delete");
      fs.rm(folderPath, { recursive: true, force: true });
    });
  });
  ipcMain.on("fakeUpdatePack", async (event, mod: Mod) => {
    try {
      const uploadFolderPath = nodePath.join(nodePath.dirname(mod.path), "whmm_backups");
      const backupFilePath = nodePath.join(
        uploadFolderPath,
        nodePath.parse(mod.name).name +
          "-" +
          format(new Date(), "dd-MM-yyyy-HH-mm") +
          nodePath.parse(mod.name).ext
      );
      const uploadFilePath = nodePath.join(
        uploadFolderPath,
        nodePath.parse(mod.name).name +
          "-NEW-" +
          format(new Date(), "dd-MM-yyyy-HH-mm") +
          nodePath.parse(mod.name).ext
      );

      await fs.mkdir(uploadFolderPath, { recursive: true });
      await fs.copyFile(mod.path, backupFilePath);
      await addFakeUpdate(mod.path, uploadFilePath);

      const command = `cd /d "${nodePath.dirname(mod.path)}" && del "${nodePath.basename(
        mod.path
      )}" && move /y "whmm_backups\\${nodePath.basename(uploadFilePath)}" "${nodePath.basename(mod.path)}"`;
      console.log(command);

      exec(command);
    } catch (e) {
      console.log(e);
    }
  });

  ipcMain.on("makePackBackup", async (event, mod: Mod) => {
    try {
      const uploadFolderPath = nodePath.join(nodePath.dirname(mod.path), "whmm_backups");
      const backupFilePath = nodePath.join(
        uploadFolderPath,
        nodePath.parse(mod.name).name +
          "-" +
          format(new Date(), "dd-MM-yyyy-HH-mm") +
          nodePath.parse(mod.name).ext
      );
      await fs.mkdir(uploadFolderPath, { recursive: true });
      await fs.copyFile(mod.path, backupFilePath);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("forceModDownload", async (event, mod: Mod) => {
    try {
      fork(nodePath.join(__dirname, "sub.js"), ["download", mod.workshopId], {});
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("reMerge", async (event, mod: Mod, modsToMerge: Mod[]) => {
    try {
      mergeMods(modsToMerge, mod.path);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("deletePack", async (event, mod: Mod) => {
    try {
      await fsExtra.remove(mod.path);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("forceDownloadMods", async (event, modIds: string[]) => {
    try {
      fork(nodePath.join(__dirname, "sub.js"), ["download", modIds.join(";")], {});
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("unsubscribeToMod", async (event, mod: Mod) => {
    try {
      fork(nodePath.join(__dirname, "sub.js"), ["unsubscribe", mod.workshopId], {});
      await fsExtra.remove(mod.path);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("mergeMods", async (event, mods: Mod[]) => {
    try {
      mergeMods(mods).then((targetPath) => {
        mainWindow?.webContents.send("createdMergedPack", targetPath);
      });
    } catch (e) {
      console.log(e);
    }
  });

  ipcMain.on("subscribeToMods", async (event, ids: string[]) => {
    fork(nodePath.join(__dirname, "sub.js"), ["sub", ids.join(";")], {});
    await new Promise((resolve) => setTimeout(resolve, 500));
    fork(nodePath.join(__dirname, "sub.js"), ["download", ids.join(";")], {});
    await new Promise((resolve) => setTimeout(resolve, 1000));
    fork(nodePath.join(__dirname, "sub.js"), ["justRun"], {});
    await new Promise((resolve) => setTimeout(resolve, 500));
    mainWindow?.webContents.send("subscribedToMods", ids);
  });

  ipcMain.on("exportModsToClipboard", async (event, mods: Mod[]) => {
    const sortedMods = sortByNameAndLoadOrder(mods);
    const enabledMods = sortedMods.filter((mod) => mod.isEnabled);

    const exportedMods = enabledMods
      .filter((mod) => !isNaN(Number(mod.workshopId)) && !isNaN(parseFloat(mod.workshopId)))
      .map((mod) => mod.workshopId + (mod.loadOrder != null ? `;${mod.loadOrder}` : ""))
      .join("|");
    clipboard.writeText(exportedMods);
  });

  const getDBsForGameStartOptions = async (mods: Mod[], startGameOptions: StartGameOptions) => {
    const tablesToRead: string[] = [];
    if (startGameOptions.isMakeUnitsGeneralsEnabled) {
      tablesToRead.push("db\\units_custom_battle_permissions_tables\\");
    }

    if (tablesToRead.length == 0) return;

    for (const mod of mods) {
      const existingPack = appData.packsData.find((pack) => pack.path == mod.path);
      console.log("READING FOR GAME START " + mod.name);
      let newPack = null;
      if (existingPack) {
        newPack = await readFromExistingPack(existingPack, {
          tablesToRead,
        });
      } else {
        newPack = await readPack(mod.path, {
          tablesToRead,
        });
      }
      appendPacksData(newPack);
    }
  };

  ipcMain.on(
    "startGame",
    async (event, mods: Mod[], startGameOptions: StartGameOptions, saveName?: string) => {
      if (!appData.gamePath) return;

      const appDataPath = app.getPath("userData");
      const userScriptPath = nodePath.join(appData.gamePath, "my_mods.txt");

      const sortedMods = sortByNameAndLoadOrder(mods);
      const enabledMods = sortedMods.filter((mod) => mod.isEnabled);

      const linuxBit = process.platform === "linux" ? "Z:" : "";
      const dataMod: Mod = {
        humanName: "",
        name: "data.pack",
        path: nodePath.join(appData.dataFolder as string, "data.pack"),
        imgPath: "",
        workshopId: "",
        isEnabled: true,
        modDirectory: `${appData.dataFolder}`,
        isInData: true,
        lastChanged: undefined,
        loadOrder: undefined,
        author: "",
        isDeleted: false,
        isMovie: false,
        size: 0,
      };

      let extraEnabledMods = "";
      if (
        startGameOptions.isMakeUnitsGeneralsEnabled ||
        startGameOptions.isScriptLoggingEnabled ||
        startGameOptions.isSkipIntroMoviesEnabled
      ) {
        await fs.mkdir(nodePath.join(appDataPath, "tempPacks"), { recursive: true });

        await getDBsForGameStartOptions(enabledMods.concat([dataMod]), startGameOptions);

        const tempPackName = "!!!!out.pack";
        const tempPackPath = nodePath.join(appDataPath, "tempPacks", tempPackName);
        await writePack(appData.packsData, tempPackPath, enabledMods.concat(dataMod), startGameOptions);
        extraEnabledMods =
          `\nadd_working_directory "${linuxBit + nodePath.join(appDataPath, "tempPacks")}";` +
          `\nmod "${tempPackName}";`;
      }

      const modPathsInsideMergedMods = enabledMods
        .filter((mod) => mod.mergedModsData)
        .map((mod) => (mod.mergedModsData as MergedModsData[]).map((mod) => mod.path))
        .flatMap((paths) => paths);

      const enabledModsWithoutMergedInMods = enabledMods.filter(
        (mod) => !modPathsInsideMergedMods.some((path) => path == mod.path)
      );

      const text =
        enabledModsWithoutMergedInMods
          .filter((mod) => nodePath.relative(appData.dataFolder as string, mod.modDirectory) != "")
          .map((mod) => `add_working_directory "${linuxBit + mod.modDirectory}";`)
          .concat(enabledModsWithoutMergedInMods.map((mod) => `mod "${mod.name}";`))
          .join("\n") + extraEnabledMods;

      await fs.writeFile(userScriptPath, text);
      const batPath = nodePath.join(appDataPath, "game.bat");
      let batData = `start /d "${appData.gamePath}" Warhammer3.exe`;
      if (saveName) {
        batData += ` game_startup_mode campaign_load "${saveName}" ;`;
      }
      batData += " my_mods.txt;";

      mainWindow?.webContents.send("handleLog", "starting game:");
      mainWindow?.webContents.send("handleLog", batData);

      await fs.writeFile(batPath, batData);
      execFile(batPath);

      if (startGameOptions.isClosedOnPlay) {
        await new Promise((resolve) => {
          setTimeout(resolve, 5000);
        });

        app.exit();
      }
    }
  );
}
