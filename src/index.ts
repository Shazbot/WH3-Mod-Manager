import { gameToProcessName, gameToSteamId } from "./supportedGames";
import { exec, fork, spawn } from "child_process";
import { app, autoUpdater, BrowserWindow, dialog, ipcMain, Menu, shell } from "electron";
import installExtension, { REACT_DEVELOPER_TOOLS, REDUX_DEVTOOLS } from "electron-extension-installer";
import fetch from "electron-fetch";
import isDev from "electron-is-dev";
import * as fs from "fs";
import { updateAvailable } from "gh-release-fetch";
import { version } from "../package.json";
import appData from "./appData";
import windowStateKeeper from "electron-window-state";
import * as nodePath from "path";
import { isMainThread } from "worker_threads";
import electronLog from "electron-log/main";
import i18n from "./configs/i18next.config";
import { globSync } from "glob";
import { windows, registerIpcMainListeners } from "./ipcMainListeners";
import * as https from "https";
import { Extract } from "unzipper";

//-------------- HOT RELOAD DOESN'T RELOAD INDEX.TS

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const gotTheLock = app.requestSingleInstanceLock();

// let mainWindow: BrowserWindow | undefined;
// let viewerWindow: BrowserWindow | undefined;
// let skillsWindow: BrowserWindow | undefined;

if (!gotTheLock) {
  console.log("ONLY ONE INSTANCE ALLOWED!");
  app.quit();
} else {
  app.commandLine.appendSwitch("js-flags", "--max-old-space-size=12288");

  console.log("ARGVS:", process.argv);
  appData.startArgs = process.argv.slice(1);

  exec("NET SESSION", function (err, so, se) {
    appData.isAdmin = se.length === 0;
    console.log("isAdmin:", appData.isAdmin);
  });

  if (process.argv.find((arg) => arg == "-nogpu")) {
    console.log("DISABLED HARDWARE ACCELERATION");
    app.disableHardwareAcceleration();
  }

  process.noAsar = true;

  // Handle creating/removing shortcuts on Windows when installing/uninstalling.
  if (require("electron-squirrel-startup")) {
    // eslint-disable-line global-require
    app.quit();
  }

  if (isMainThread) {
    process.umask(0);

    console.log = (...args) => {
      electronLog.info(...args);
    };
  }

  let checkWH3RunningInterval: NodeJS.Timer;

  const createWindow = (): void => {
    i18n.on("loaded", async () => {
      i18n.changeLanguage("en");
      i18n.off("loaded");

      console.log("I18 ON");
    });

    const mainWindowState = windowStateKeeper({
      file: "main_window.json",
      defaultWidth: 1280,
      defaultHeight: 900,
    });

    // Create the browser window.
    windows.mainWindow = new BrowserWindow({
      x: mainWindowState.x,
      y: mainWindowState.y,
      width: mainWindowState.width,
      height: mainWindowState.height,
      autoHideMenuBar: true,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#374151",
        symbolColor: "#9ca3af",
        height: 28,
      },
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
      title: "WH3 Mod Manager",
      icon: "./assets/modmanager.ico",
    });

    mainWindowState.manage(windows.mainWindow);

    // and load the index.html of the app.
    windows.mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    windows.mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: "deny" };
    });

    // const server = "https://hazel-neon-gamma.vercel.app";
    // const url = `${server}/update/${process.platform}/${app.getVersion()}`;

    // autoUpdater.setFeedURL({ url });
    // setInterval(() => {
    //   try {
    //     autoUpdater.checkForUpdates();
    //   } catch {}
    // }, 60000);
    // try {
    //   autoUpdater.checkForUpdates();
    // } catch {}

    // if (isDev) mainWindow?.webContents.openDevTools();

    if (isDev) {
      // no idea why but openDevTools is really uncooperative, this isn't great but it works
      setTimeout(() => {
        windows.mainWindow?.webContents.openDevTools({ mode: "right" });
      }, 25000);
    }

    autoUpdater.on("update-downloaded", (event, releaseNotes, releaseName) => {
      const dialogOpts = {
        type: "info" as const,
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? releaseNotes : releaseName,
        detail: "A new version has been downloaded. Restart the application to apply the updates.",
      };

      dialog.showMessageBox(dialogOpts).then((returnValue) => {
        if (returnValue.response === 0) autoUpdater.quitAndInstall();
      });
    });
    autoUpdater.on("error", (message) => {
      console.error("There was a problem updating the application");
      console.error(message);
    });

    windows.mainWindow.on("page-title-updated", (evt) => {
      evt.preventDefault();
    });

    windows.mainWindow.on("closed", () => {
      if (windows.viewerWindow) windows.viewerWindow.close();
      if (windows.skillsWindow) windows.skillsWindow.close();
    });

    const waitForModDownloads = async () => {
      if (appData.waitForModIds.length == 0) return;

      const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
      if (!contentFolder) return;

      const downloadsFolder = nodePath.join(contentFolder, "..", "..", "downloads");
      console.log("downloads folder:", downloadsFolder);

      // should we stop if something is currently being downloaded? after some testing, no
      // if (globSync(`*${gameToSteamId[appData.currentGame]}*`, { cwd: downloadsFolder }).length != 0) {
      //   console.log("something for the current game is being downloaded!");
      //   return;
      // }

      const toRemoveFromWaitForModIds: string[] = [];
      const idsToDownload: string[] = [];
      for (const modId of appData.waitForModIds) {
        console.log("checking", nodePath.join(contentFolder, modId));
        if (globSync("*.pack", { cwd: nodePath.join(contentFolder, modId) }).length == 0)
          idsToDownload.push(modId);
        else toRemoveFromWaitForModIds.push(modId);
      }

      console.log("ids to download:", idsToDownload);
      fork(
        nodePath.join(__dirname, "sub.js"),
        [gameToSteamId[appData.currentGame], "download", idsToDownload.join(";")],
        {}
      );

      appData.waitForModIds = appData.waitForModIds.filter(
        (modId) => !toRemoveFromWaitForModIds.includes(modId)
      );
    };
    setInterval(waitForModDownloads, 3500);

    registerIpcMainListeners(windows.mainWindow, isDev);

    ipcMain.removeHandler("getUpdateData");
    ipcMain.handle("getUpdateData", async () => {
      // if (isDev) return;

      // clean up the temp_update folder
      try {
        if (fs.existsSync("./temp_update")) {
          fs.rmSync("./temp_update", { force: true, recursive: true });
        }
      } catch (e) {
        console.log(e);
      }

      let modUpdatedExists = { updateExists: false } as ModUpdateExists;

      const isAvailable = await updateAvailable("Shazbot/WH3-Mod-Manager", version);
      if (!isAvailable) return modUpdatedExists;

      await fetch(`https://api.github.com/repos/Shazbot/WH3-Mod-Manager/releases/latest`)
        .then((res) => res.json())
        .then((body) => {
          body.assets.forEach((asset: { content_type: string; browser_download_url: string }) => {
            windows.mainWindow?.webContents.send(
              "handleLog",
              asset.content_type == "application/x-zip-compressed"
            );
            if (asset.content_type === "application/x-zip-compressed") {
              modUpdatedExists = {
                updateExists: true,
                downloadURL: asset.browser_download_url,
              } as ModUpdateExists;
            }
          });

          if (body.html_url) modUpdatedExists.releaseNotesURL = body.html_url;
        })
        .catch();

      return modUpdatedExists;
    });

    // Handle auto-update download and installation
    ipcMain.handle("downloadAndInstallUpdate", async (event, downloadURL: string) => {
      console.log("downloadAndInstallUpdate:", downloadURL);
      if (isDev) {
        return { success: false, error: "Updates not available in development mode" };
      }

      try {
        const appPath = app.getAppPath();
        const tempDir = nodePath.join(appPath, "../..", "temp_update");
        const zipPath = nodePath.join(tempDir, "update.zip");

        // Create temp directory
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir, { recursive: true });
        }

        // Download the update file
        const downloadFile = (url: string, dest: string, fileOut?: fs.WriteStream): Promise<void> => {
          return new Promise((resolve, reject) => {
            const file = fileOut || fs.createWriteStream(dest);
            https
              .get(url, (response) => {
                if (response.statusCode === 302 || response.statusCode === 301) {
                  // Handle redirect
                  return downloadFile(response.headers.location!, dest, file).then(resolve).catch(reject);
                }

                response.on("end", () => {
                  file.close();
                  resolve();
                });
                response.pipe(file);
              })
              .on("error", (err) => {
                fs.unlink(dest, () => {}); // Delete the file async
                reject(err);
              });
          });
        };

        if (fs.existsSync(zipPath)) {
          fs.rmSync(zipPath);
        }
        await downloadFile(downloadURL, zipPath);

        // Extract the zip file to a staging directory
        const stagingDir = nodePath.join(tempDir, "staging");
        await new Promise<void>((resolve, reject) => {
          fs.createReadStream(zipPath)
            .pipe(Extract({ path: stagingDir }))
            .on("close", resolve)
            .on("error", reject);
        });

        // Create update script
        const appDir = nodePath.dirname(nodePath.join(appPath, ".."));
        const updateScript = nodePath.join(tempDir, "update.bat");
        const appExeName = nodePath.basename(process.execPath);

        const processId = process.pid;
        const scriptContent = `@echo off
          echo Waiting for application to close...
          :wait_loop
          tasklist /FI "PID eq ${processId}" | find "${processId}" >nul
          if errorlevel 1 goto continue_update
          timeout /t 1 /nobreak >nul
          goto wait_loop

          :continue_update
          echo Application closed. Starting update...
          timeout /t 1 /nobreak >nul
          xcopy /E /Y /I "${stagingDir}\\*" "${appDir}\\"
          if errorlevel 1 (
              echo Update failed!
              pause
              exit /b 1
          )
          echo Update complete! Starting application...
          powershell "start \"${nodePath.join(appDir, appExeName)}\""
          echo Cleaning up...
          timeout /t 2 /nobreak >nul
          rd /s /q "${tempDir}"
          del "%~f0"
          exit /b`;

        fs.writeFileSync(updateScript, scriptContent);

        // Show dialog and execute update
        const result = await dialog.showMessageBox(windows.mainWindow!, {
          type: "info",
          title: i18n.t("updateReady"),
          message: i18n.t("updateReadyMessage"),
          buttons: [i18n.t("updateNow"), i18n.t("cancel")],
        });

        if (result.response === 0) {
          // Launch update script and exit
          const subprocess = spawn(`start cmd.exe /c update.bat`, [], {
            cwd: tempDir,
            shell: true,
            detached: true,
            windowsHide: true,
          });
          subprocess.unref();
          // exec(`"${updateScript}"`, { detached: true });
          app.quit();
        } else {
          // Cleanup if user cancels
          fs.rmSync(tempDir, { recursive: true, force: true });
        }

        return { success: true };
      } catch (error) {
        console.error("Update download/install failed:", error);

        // Show error dialog
        await dialog.showErrorBox(
          i18n.t("updateFailed"),
          `${i18n.t("updateFailedMessage")} ${error instanceof Error ? error.message : String(error)}`
        );

        return { success: false, error: error instanceof Error ? error.message : String(error) };
      }
    });

    ipcMain.on("sendApiExists", async () => {
      windows.mainWindow?.webContents.send("handleLog", "API now exists");
      windows.mainWindow?.webContents.send("setIsDev", isDev);
      windows.mainWindow?.webContents.send("setStartArgs", appData.startArgs);
      windows.mainWindow?.webContents.send("setIsAdmin", appData.isAdmin);

      try {
        const localesPath = isDev ? "./locales/" : "./resources/app/.webpack/main/locales";
        const availableLocalizations = (await fs.readdirSync(localesPath, { withFileTypes: true }))
          .filter((dirent) => dirent.isDirectory())
          .map((dirent) => dirent.name);

        windows.mainWindow?.webContents.send("setAvailableLanguages", availableLocalizations);
        // eslint-disable-next-line no-empty
      } catch (e) {}

      if (!checkWH3RunningInterval) {
        const isGameRuningCheck = async () => {
          try {
            // if a game crashes you can end up with a tiny running process of the game, that's why we have a memory filter here
            exec(
              `tasklist /nh /fi "IMAGENAME eq ${
                gameToProcessName[appData.currentGame]
              }" /fi "MEMUSAGE gt 10000"`,
              (_, stdout) => {
                const isWH3Running = stdout.includes(gameToProcessName[appData.currentGame]);
                if (appData.isWH3Running != isWH3Running) {
                  appData.isWH3Running = isWH3Running;
                  windows.mainWindow?.webContents.send("setIsWH3Running", appData.isWH3Running);
                }
                if (checkWH3RunningInterval) checkWH3RunningInterval.refresh();
              }
            );
          } catch (e) {
            console.log("psList coroutine error:", e);
          }
        };
        checkWH3RunningInterval = setTimeout(isGameRuningCheck, 500);
      }
    });
  };

  app.on("second-instance", () => {
    // Someone tried to run a second instance, we should focus our window.
    if (windows.mainWindow) {
      if (windows.mainWindow.isMinimized()) windows.mainWindow.restore();
      windows.mainWindow.focus();
    }
  });

  // not using a default menu
  Menu.setApplicationMenu(null);

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on("ready", createWindow);

  app.whenReady().then(() => {
    installExtension(REACT_DEVELOPER_TOOLS, {
      loadExtensionOptions: {
        allowFileAccess: true,
      },
    })
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));

    installExtension(REDUX_DEVTOOLS, {
      loadExtensionOptions: {
        allowFileAccess: true,
      },
    })
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));
  });

  // Quit when all windows are closed, except on macOS. There, it's common
  // for applications and their menu bar to stay active until the user quits
  // explicitly with Cmd + Q.
  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });

  process.on("unhandledRejection", (err) => {
    console.log(err);
  });
  process.on("uncaughtException", (err) => {
    console.log(err);
  });
}
