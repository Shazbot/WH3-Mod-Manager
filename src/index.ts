import {
  SupportedGames,
  gameToGameName,
  gameToProcessName,
  gameToSteamId,
  gameToSupportedGameOptions,
  supportedGameOptionToStartGameOption,
  supportedGameOptions,
  gameToVanillaPacksData,
} from "./supportedGames";
import * as cheerio from "cheerio";
import debounce from "just-debounce-it";
import psList from "ps-list";
import { Pack, PackCollisions } from "./packFileTypes";
import { execFile, exec, fork } from "child_process";
import { app, autoUpdater, BrowserWindow, clipboard, dialog, ipcMain, shell } from "electron";
import installExtension, { REACT_DEVELOPER_TOOLS, REDUX_DEVTOOLS } from "electron-extension-installer";
import fetch from "electron-fetch";
import isDev from "electron-is-dev";
import * as fs from "fs";
import { updateAvailable } from "gh-release-fetch";
import { version } from "../package.json";
import { sortByNameAndLoadOrder } from "./modSortingHelpers";
import { readAppConfig, setStartingAppState, writeAppConfig } from "./appConfigFunctions";
import {
  fetchModData,
  getContentModInFolder,
  getDataMod,
  getFolderPaths,
  getLastUpdated,
  getMods,
} from "./modFunctions";
import appData, { GameFolderPaths } from "./appData";
import chokidar from "chokidar";
import { getSaveFiles, setupSavesWatcher } from "./gameSaves";
import windowStateKeeper from "electron-window-state";
import { readPackHeader } from "./packFileHandler";
import {
  addFakeUpdate,
  getPacksInSave,
  mergeMods,
  readPack,
  writePack,
  readFromExistingPack,
  createOverwritePack,
  getPackViewData,
  appendPackFileCollisions,
  appendPackTableCollisions,
  removeFromPackFileCollisions,
  removeFromPackTableCollisions,
} from "./packFileSerializer";
import * as nodePath from "path";
import { format } from "date-fns";
import { isMainThread } from "worker_threads";
import electronLog from "electron-log";
import * as fsExtra from "fs-extra";
import { getCompatData } from "./packFileDataManager";
import steamCollectionScript from "./utility/steamCollectionScript";
import i18n from "./configs/i18next.config";
import { tryOpenFile } from "./utility/fileHelpers";
import { collator } from "./utility/packFileSorting";

//-------------- HOT RELOAD DOESN'T RELOAD INDEX.TS

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VIEWER_WEBPACK_ENTRY: string;
declare const VIEWER_PRELOAD_WEBPACK_ENTRY: string;

const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  console.log("ONLY ONE INSTANCE ALLOWED!");
  app.quit();
} else {
  console.log("ARGVS:", process.argv);
  appData.startArgs = process.argv.slice(1);

  exec("NET SESSION", function (err, so, se) {
    appData.isAdmin = se.length === 0;
    console.log("isAdmin:", appData.isAdmin);
  });

  if (process.argv.find((arg) => arg == "-nogpu")) {
    console.log("DISABLED HARDWARE ACCELERATION");
    app.disableHardwareAcceleration();
  }

  process.noAsar = true;

  // Handle creating/removing shortcuts on Windows when installing/uninstalling.
  if (require("electron-squirrel-startup")) {
    // eslint-disable-line global-require
    app.quit();
  }

  if (isMainThread) {
    process.umask(0);

    console.log = (...args) => {
      electronLog.info(...args);
    };
  }

  let mainWindow: BrowserWindow | undefined;
  let viewerWindow: BrowserWindow | undefined;
  let contentWatcher: chokidar.FSWatcher | undefined;
  let dataWatcher: chokidar.FSWatcher | undefined;
  let downloadsWatcher: chokidar.FSWatcher | undefined;
  let mergedWatcher: chokidar.FSWatcher | undefined;
  let queuedViewerData: (PackViewData | undefined)[];
  let isViewerReady = false;
  let checkWH3RunningInterval: NodeJS.Timer;

  const tempModDatas: ModData[] = [];
  const sendModData = debounce(() => {
    mainWindow?.webContents.send("setModData", [...tempModDatas]);
    tempModDatas.splice(0, tempModDatas.length);
  }, 200);

  const readConfig = async (): Promise<AppStateToRead> => {
    try {
      const appState = await readAppConfig();
      if (!appData.hasReadConfig) {
        fork(nodePath.join(__dirname, "sub.js"), [gameToSteamId[appData.currentGame], "justRun"], {}); // forces steam workshop to download mods
        setStartingAppState(appState);
      }

      // appFolderPaths is deprecated in the config since we moved from only supporting wh3, this is migration code
      if (appState.appFolderPaths) {
        if (appState.appFolderPaths.contentFolder && !fs.existsSync(appState.appFolderPaths.contentFolder)) {
          appState.appFolderPaths.contentFolder = "";
        } else {
          appData.gamesToGameFolderPaths["wh3"].contentFolder = appState.appFolderPaths.contentFolder;
        }

        if (appState.appFolderPaths.gamePath && !fs.existsSync(appState.appFolderPaths.gamePath)) {
          appState.appFolderPaths.gamePath = "";
        } else {
          appData.gamesToGameFolderPaths["wh3"].gamePath = appState.appFolderPaths.gamePath;

          if (appState.appFolderPaths.gamePath)
            appData.gamesToGameFolderPaths["wh3"].dataFolder = nodePath.join(
              appState.appFolderPaths.gamePath,
              "/data/"
            );
        }
      }

      if (appState.gameFolderPaths) {
        appData.gamesToGameFolderPaths = appState.gameFolderPaths;

        if (appState.currentGame) {
          const gameFolderPaths = appData.gamesToGameFolderPaths[appState.currentGame];

          if (gameFolderPaths.contentFolder && !fs.existsSync(gameFolderPaths.contentFolder)) {
            gameFolderPaths.contentFolder = "";
          }
          if (gameFolderPaths.gamePath && !fs.existsSync(gameFolderPaths.gamePath)) {
            gameFolderPaths.gamePath = "";
          }
        }
      }

      if (appState.currentGame) {
        appData.currentGame = appState.currentGame;
      } else {
        appState.currentGame = appData.currentGame;
      }

      if (appState.gameToCurrentPreset) {
        appData.gameToCurrentPreset = appState.gameToCurrentPreset;
      } else {
        appState.gameToCurrentPreset = appData.gameToCurrentPreset;
      }
      if (appState.gameToPresets) {
        appData.gameToPresets = appState.gameToPresets;
      } else {
        appState.gameToPresets = appData.gameToPresets;
      }

      // presets and currentPreset is also deprecated and now in gameToPresets and gameToCurrentPreset, migration code
      if (appState.currentPreset) {
        appData.gameToCurrentPreset["wh3"] = appState.currentPreset;
      } else if (appData.gameToCurrentPreset[appState.currentGame]) {
        appState.currentPreset = appData.gameToCurrentPreset[appState.currentGame] as Preset;
      }
      if (appState.presets) {
        appData.gameToPresets["wh3"] = appState.presets;
      } else {
        appState.presets = appData.gameToPresets[appState.currentGame];
      }

      return appState;
    } finally {
      appData.hasReadConfig = true;
    }
  };

  const log = (msg: string) => {
    mainWindow?.webContents.send("handleLog", msg);
    console.log(msg);
  };

  const removeMod = async (mainWindow: BrowserWindow, modPath: string) => {
    mainWindow?.webContents.send("removeMod", modPath);
  };

  const getMod = async (mainWindow: BrowserWindow, modPath: string) => {
    let mod: Mod | undefined;
    try {
      if (modPath.includes(`\\content\\${gameToSteamId[appData.currentGame]}\\`)) {
        const modSubfolderName = nodePath.dirname(modPath).replace(/.*\\/, "");
        console.log("looking for ", modSubfolderName);
        mod = await getContentModInFolder(modSubfolderName, log);
      } else {
        console.log("looking for DATA MOD: ", modPath);
        mod = await getDataMod(modPath, log);
      }
    } catch (e) {
      console.log(e);
    }

    return mod;
  };

  const appendPacksData = (newPack: Pack, mod?: Mod) => {
    const existingPack = appData.packsData.find((pack) => pack.path == newPack.path);
    console.log("appendPacksData: appending", newPack.name);
    console.log("appendPacksData: is existingPack:", !!existingPack);

    if (!existingPack) {
      appData.packsData.push(newPack);
      mainWindow?.webContents.send("setPacksDataRead", [newPack.path]);

      if (
        appData.vanillaPacks.length == gameToVanillaPacksData[appData.currentGame].length &&
        !appData.vanillaPacks.find((vanillaPack) => vanillaPack == newPack)
      ) {
        const overwrittenFileNames = newPack.packedFiles
          .map((packedFile) => packedFile.name)
          .filter(
            (packedFileName) => packedFileName.match(/^db\\.*\\data__/) || packedFileName.endsWith(".lua")
          )
          .filter((packedFileName) => {
            let foundMatchingFile = false;
            for (const vanillaPack of appData.vanillaPacks) {
              foundMatchingFile ||= vanillaPack.packedFiles.some(
                (packedFileInData) => packedFileInData.name == packedFileName
              );
            }
            return foundMatchingFile;
          });
        if (overwrittenFileNames.length > 0) {
          appData.overwrittenDataPackedFiles[newPack.name] = overwrittenFileNames;
          mainWindow?.webContents.send("setOverwrittenDataPackedFiles", appData.overwrittenDataPackedFiles);
        }

        const outdatedPackFiles = new Set<string>();
        if (appData.currentGame == "wh3" && mod && (mod.lastChangedLocal || mod.lastChanged)) {
          const lastChanged = mod.lastChanged || mod.lastChangedLocal;
          if (lastChanged) {
            appData.gameUpdates
              .filter((gameUpdate) => parseInt(gameUpdate.timestamp) * 1000 - lastChanged > 0)
              .reduce((acc, current) => {
                if (current.files) {
                  current.files
                    .filter((fileUpdateRule) => {
                      const ret = newPack.packedFiles.some((pF) => pF.name.search(fileUpdateRule.regex) > -1);
                      // if (ret)
                      //   console.log(
                      //     "file match",
                      //     newPack.packedFiles.find((pF) => pF.name.search(fileUpdateRule.regex) > -1)?.name,
                      //     "regex",
                      //     fileUpdateRule.regex,
                      //     "ret",
                      //     ret
                      //   );
                      return ret;
                    })
                    .map((updateRule) => `${current.version}: ${updateRule.reason}`)
                    .forEach((updateStr) => acc.add(updateStr));
                }
                return acc;
              }, outdatedPackFiles);
          }
        }
        console.log("outdatedPackFiles", outdatedPackFiles);
        if (outdatedPackFiles.size > 0) {
          appData.outdatedPackFiles[newPack.name] = Array.from(outdatedPackFiles);
          mainWindow?.webContents.send("setOutdatedPackFiles", appData.outdatedPackFiles);
        }
      }
    } else {
      console.log("existing pack for", newPack.name, "found");
      // append list of tables that are parsed in that pack
      if (newPack.readTables == "all") {
        existingPack.readTables = "all";
      } else {
        newPack.readTables.forEach((newlyRead) => {
          if (existingPack.readTables != "all" && !existingPack.readTables.includes(newlyRead)) {
            existingPack.readTables.push(newlyRead);
          }
        });
      }
      newPack.packedFiles
        .filter((packedFile) => packedFile.schemaFields)
        .forEach((newPackedFile) => {
          const index = existingPack.packedFiles.findIndex(
            (existingPackedFile) => existingPackedFile.name == newPackedFile.name
          );
          if (index != -1) {
            existingPack.packedFiles.splice(index, 1);
          }
          existingPack.packedFiles.push(newPackedFile);
        });
    }
  };

  const appendCollisions = async (newPack: Pack) => {
    while (!appData.compatData) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    if (appData.compatData) {
      appData.compatData.packTableCollisions = appendPackTableCollisions(
        appData.packsData,
        appData.compatData.packTableCollisions,
        newPack
      );
      appData.compatData.packFileCollisions = appendPackFileCollisions(
        appData.packsData,
        appData.compatData.packFileCollisions,
        newPack
      );
    }
  };

  const onNewPackFound = async (path: string) => {
    if (!mainWindow) return;
    mainWindow.webContents.send("handleLog", "MOD ADDED: " + path);
    console.log("MOD ADDED: " + path);

    const mod = await getMod(mainWindow, path);
    if (mod) {
      mainWindow?.webContents.send("addMod", mod);
    }
  };
  const onPackDeleted = async (path: string, isDeletedFromContent = false) => {
    if (!mainWindow) return;
    mainWindow.webContents.send("handleLog", "MOD REMOVED: " + path);

    console.log("MOD REMOVED: " + path);
    await removeMod(mainWindow, path);

    if (appData.packsData && appData.packsData.some((pack) => pack.path == path)) {
      appData.packsData = appData.packsData.filter((pack) => pack.path != path);
    }

    const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
    if (isDeletedFromContent && dataFolder) {
      try {
        const potentialSymlinkDataPath = nodePath.join(dataFolder, nodePath.basename(path));
        await fs.readlinkSync(potentialSymlinkDataPath);
        await fs.unlinkSync(potentialSymlinkDataPath);
        await removeMod(mainWindow, path);
      } catch (e) {
        console.log("deleted content pack doesn't have a symbolic link in data");
        console.log(e);
      }
    }

    removePackFromCollisions(path);
  };

  const removePackFromCollisions = (packPath: string) => {
    if (appData.compatData) {
      appData.compatData.packTableCollisions = removeFromPackTableCollisions(
        appData.compatData.packTableCollisions,
        nodePath.basename(packPath)
      );
      appData.compatData.packFileCollisions = removeFromPackFileCollisions(
        appData.compatData.packFileCollisions,
        nodePath.basename(packPath)
      );
    }
  };

  const setLastGameUpdateTimeUsingAppManifest = async () => {
    try {
      const timeOfLastGameUpdate = await getLastUpdated();
      if (timeOfLastGameUpdate) {
        mainWindow?.webContents.send("setDataModLastChangedLocal", parseInt(timeOfLastGameUpdate) * 1000);
      }
    } catch (e) {
      console.log(e);
    }
  };

  const fetchGameUpdates = async () => {
    try {
      if (appData.currentGame != "wh3") return await setLastGameUpdateTimeUsingAppManifest();

      const res = await fetch(
        `https://raw.githubusercontent.com/Shazbot/WH3-Mod-Manager/tw_updates/tw_updates/wh3.json`
      );
      // eslint-disable-next-line prefer-const
      let gameUpdates = (await res.json()) as GameUpdateData[];
      // if (isDev) {
      //   gameUpdates = JSON.parse(fsdumb.readFileSync("./test/wh3.json", "utf-8")) as GameUpdateData[];
      // }
      appData.gameUpdates = gameUpdates;
      console.log("gameUpdates", gameUpdates);
      gameUpdates.sort((a, b) => parseInt(b.timestamp) - parseInt(a.timestamp));

      if (gameUpdates[0]) {
        mainWindow?.webContents.send("setDataModLastChangedLocal", parseInt(gameUpdates[0].timestamp) * 1000);
      }
    } catch (e) {
      console.log(e);
    }
  };

  const getAllMods = async () => {
    try {
      const mods = await getMods(log);
      mainWindow?.webContents.send("modsPopulated", mods);

      mods.forEach(async (mod) => {
        try {
          if (mod == null || mod.path == null) {
            console.error("MOD OR MOD PATH IS NULL");
          }
          const packHeaderData = await readPackHeader(mod.path);
          if (packHeaderData.isMovie || packHeaderData.dependencyPacks.length > 0)
            mainWindow?.webContents.send("setPackHeaderData", packHeaderData);
        } catch (e) {
          if (e instanceof Error) {
            log(e.message);
          }
        }
      });

      if (!appData.saveSetupDone) {
        appData.saveSetupDone = true;
        getSaveFiles()
          .then(async (saves) => {
            await setupSavesWatcher((saves) => mainWindow?.webContents.send("savesPopulated", saves));
            mainWindow?.webContents.send("savesPopulated", saves);
          })
          .catch();
      }

      const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
      if (dataFolder) {
        for (const vanillaPackData of gameToVanillaPacksData[appData.currentGame]) {
          const baseVanillaPackName = vanillaPackData.name;
          const dataPackPath = nodePath.join(dataFolder, baseVanillaPackName);
          const dataMod: Mod = {
            humanName: "",
            name: baseVanillaPackName,
            path: dataPackPath,
            imgPath: "",
            workshopId: "",
            isEnabled: true,
            modDirectory: `${dataFolder}`,
            isInData: true,
            lastChanged: undefined,
            loadOrder: undefined,
            author: "",
            isDeleted: false,
            isMovie: false,
            size: 0,
            isSymbolicLink: false,
          };
          if (appData.packsData.every((iterPack) => iterPack.path != dataPackPath)) {
            console.log("READING DATA PACK");
            appData.currentlyReadingModPaths.push(dataPackPath);
            const dataPackData = await readPack(dataMod.path, {
              // tablesToRead: ["db\\units_custom_battle_permissions_tables\\"],
              skipParsingTables: true,
            });
            appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
              (path) => path != dataPackPath
            );
            if (dataPackData) {
              appData.vanillaPacks.push(dataPackData);

              const vanillaDBFileNames = dataPackData.packedFiles
                .map((vanillaDBFileName) => vanillaDBFileName.name.match(/^db\\(.*?)\\data__/))
                .filter((matchResult) => matchResult)
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                .map((matchResult) => matchResult![1]);

              if (vanillaDBFileNames.length > 0) {
                appData.vanillaPacksDBFileNames = Array.from(
                  new Set([...appData.vanillaPacksDBFileNames, ...vanillaDBFileNames]).values()
                );
              }
            }
            if (appData.packsData.every((iterPack) => iterPack.path != dataPackData.path)) {
              appendPacksData(dataPackData);
            }
          }
        }
        appData.vanillaPacksDBFileNames.sort((a, b) => collator.compare(a, b));

        await fetchGameUpdates();
      }

      try {
        fork(
          nodePath.join(__dirname, "sub.js"),
          [
            gameToSteamId[appData.currentGame],
            "checkState",
            mods
              .filter(
                (mod) => !mod.isInData && !isNaN(Number(mod.workshopId)) && !isNaN(parseFloat(mod.workshopId))
              )
              .map((mod) => mod.workshopId)
              .join(";"),
          ],
          {}
        );
      } catch (e) {
        console.log(e);
      }
    } catch (err) {
      console.log(err);
    }

    await contentWatcher?.close();
    contentWatcher = undefined;
    await dataWatcher?.close();
    dataWatcher = undefined;
    await downloadsWatcher?.close();
    downloadsWatcher = undefined;
    await mergedWatcher?.close();
    mergedWatcher = undefined;

    const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
    const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
    const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
    if (!contentFolder || !dataFolder || !gamePath) return;

    if (!contentWatcher) {
      const sanitizedContentFolder = contentFolder.replaceAll("\\", "/").replaceAll("//", "/");
      console.log("content folder:", contentFolder);
      contentWatcher = chokidar
        .watch(`${sanitizedContentFolder}/**/*.pack`, {
          ignoreInitial: true,
          ignored: /whmm_backups/,
          awaitWriteFinish: {
            stabilityThreshold: 2000,
            pollInterval: 100,
          },
        })
        .on("add", async (path) => {
          console.log("NEW CONTENT ADD", path);
          onNewPackFound(path);
        })
        .on("unlink", async (path) => {
          console.log("NEW CONTENT UNLINK", path);
          onPackDeleted(path, true);
        })
        .on("change", async (path) => {
          console.log("NEW CONTENT CHANGE", path);
          onPackDeleted(path);
          onNewPackFound(path);
        });
    }
    if (!downloadsWatcher) {
      const downloadsFolder = contentFolder
        .replaceAll("\\", "/")
        .replaceAll("//", "/")
        .replace("/content/", "/downloads/");
      console.log("downloads folder:", downloadsFolder);
      downloadsWatcher = chokidar
        .watch(`${downloadsFolder}/**/*.pack`, {
          ignoreInitial: true,
          awaitWriteFinish: true,
          ignored: /whmm_backups/,
        })
        .on("add", async (path) => {
          console.log("NEW DOWNLOADS ADD", path);
          fork(nodePath.join(__dirname, "sub.js"), [gameToSteamId[appData.currentGame], "justRun"], {});
        })
        .on("unlink", async (path) => {
          console.log("NEW DOWNLOADS UNLINK", path);
        });
    }
    if (!dataWatcher) {
      const sanitizedDataFolder = dataFolder.replaceAll("\\", "/").replaceAll("//", "/");
      dataWatcher = chokidar
        .watch([`${sanitizedDataFolder}/*.pack`], {
          ignoreInitial: true,
          awaitWriteFinish: true,
          followSymlinks: false,
          ignored: /whmm_backups/,
        })
        .on("add", async (path) => {
          onNewPackFound(path);
        })
        .on("unlink", async (path) => {
          onPackDeleted(path);
        })
        .on("change", async (path) => {
          console.log("data pack changed:", path);
          onPackDeleted(path);
          onNewPackFound(path);
        });
    }
    if (!mergedWatcher) {
      const mergedDirPath = nodePath.join(gamePath, "/merged/");
      exec(`mkdir "${mergedDirPath}"`);

      while (!fsExtra.existsSync(mergedDirPath)) {
        await new Promise((resolve) => {
          setTimeout(resolve, 100);
        });
      }

      // await fsExtra.ensureDir(nodePath.join(gamePath, "/merged/"));
      const sanitizedGamePath = gamePath.replaceAll("\\", "/").replaceAll("//", "/");
      mergedWatcher = chokidar
        .watch([`${sanitizedGamePath}/merged/*.pack`], {
          ignoreInitial: false,
          awaitWriteFinish: {
            stabilityThreshold: 3000,
            pollInterval: 100,
          },
          ignored: /whmm_backups/,
          usePolling: true,
        })
        .on("add", async (path) => {
          onNewPackFound(path);
        })
        .on("unlink", async (path) => {
          onPackDeleted(path);
        })
        .on("change", async (path) => {
          console.log("pack changed:", path);
          onPackDeleted(path);
          onNewPackFound(path);
        });
    }
  };

  const createWindow = (): void => {
    i18n.on("loaded", async () => {
      i18n.changeLanguage("en");
      i18n.off("loaded");

      console.log("I18 ON");
    });

    const mainWindowState = windowStateKeeper({
      file: "main_window.json",
      defaultWidth: 1280,
      defaultHeight: 900,
    });

    // Create the browser window.
    mainWindow = new BrowserWindow({
      x: mainWindowState.x,
      y: mainWindowState.y,
      width: mainWindowState.width,
      height: mainWindowState.height,
      autoHideMenuBar: true,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#374151",
        symbolColor: "#9ca3af",
        height: 28,
      },
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
      title: "WH3 Mod Manager",
      icon: "./assets/modmanager.ico",
    });

    mainWindowState.manage(mainWindow);

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
      shell.openExternal(url);
      return { action: "deny" };
    });

    // const server = "https://hazel-neon-gamma.vercel.app";
    // const url = `${server}/update/${process.platform}/${app.getVersion()}`;

    // autoUpdater.setFeedURL({ url });
    // setInterval(() => {
    //   try {
    //     autoUpdater.checkForUpdates();
    //   } catch {}
    // }, 60000);
    // try {
    //   autoUpdater.checkForUpdates();
    // } catch {}

    // if (isDev) mainWindow?.webContents.openDevTools();

    autoUpdater.on("update-downloaded", (event, releaseNotes, releaseName) => {
      const dialogOpts = {
        type: "info",
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? releaseNotes : releaseName,
        detail: "A new version has been downloaded. Restart the application to apply the updates.",
      };

      dialog.showMessageBox(dialogOpts).then((returnValue) => {
        if (returnValue.response === 0) autoUpdater.quitAndInstall();
      });
    });
    autoUpdater.on("error", (message) => {
      console.error("There was a problem updating the application");
      console.error(message);
    });

    mainWindow.on("page-title-updated", (evt) => {
      evt.preventDefault();
    });

    mainWindow.on("show", () => {
      if (isDev) mainWindow?.webContents.openDevTools();
    });

    mainWindow.on("closed", () => {
      if (viewerWindow) viewerWindow.close();
    });

    ipcMain.on("getAllModData", (event, ids: string[]) => {
      if (isDev) return;

      fetchModData(
        ids.filter((id) => id !== ""),
        (modData) => {
          tempModDatas.push(modData);
          sendModData();
        },
        (msg) => {
          mainWindow?.webContents.send("handleLog", msg);
          console.log(msg);
        }
      );
    });

    ipcMain.on("getCustomizableMods", (event, modPaths: string[], tables: string[]) => {
      const packs = appData.packsData.filter((pack) => modPaths.includes(pack.path));

      // console.log("modPaths:", modPaths);
      // console.log(
      //   "modPaths packsdata:",
      //   appData.packsData.map((pd) => pd.name)
      // );
      // console.log(packs.map((pack) => pack.packedFiles.map((pf) => pf.name).join(",")));

      // console.log("tables for matching:", tables);

      const tablesForMatching = tables.map((table) => `db\\${table}\\`);
      // console.log("tables for matching 2:", tablesForMatching);
      const customizableMods = packs.reduce((acc, currentPack) => {
        const foundTables = tablesForMatching.filter((tableForMatching) =>
          currentPack.packedFiles.some((packedFile) => packedFile.name.includes(tableForMatching))
        );
        if (foundTables.length > 0) {
          acc[currentPack.path] = foundTables;
        }
        return acc;
      }, {} as Record<string, string[]>);
      // console.log("customizable mods:", customizableMods);

      mainWindow?.webContents.send("setCustomizableMods", customizableMods);
    });

    ipcMain.on("getPacksInSave", async (event, saveName: string) => {
      mainWindow?.webContents.send("packsInSave", await getPacksInSave(saveName));
    });

    ipcMain.on("readAppConfig", async () => {
      try {
        try {
          const appState = await readConfig();
          mainWindow?.webContents.send("fromAppConfig", appState);

          const languageInConfig = appState.currentLanguage || "en";
          if (i18n.language != languageInConfig) i18n.changeLanguage(languageInConfig);
        } catch (err) {
          mainWindow?.webContents.send("failedReadingConfig");
          if (err instanceof Error) console.log(err.message);
        }

        const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
        const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
        const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
        if (!gamePath || !contentFolder || !dataFolder) {
          await getFolderPaths(log);
        }

        getAllMods();
      } finally {
        const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
        const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
        console.log("SENDING setAppFolderPaths", gamePath, contentFolder);
        mainWindow?.webContents.send("setAppFolderPaths", {
          gamePath: gamePath || "",
          contentFolder: contentFolder || "",
        } as GameFolderPaths);
      }
    });

    const refreshModsIfFoldersValid = () => {
      const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
      const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
      const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
      if (contentFolder && gamePath && dataFolder) {
        console.log(contentFolder, gamePath, dataFolder);
        getAllMods();
      }
    };

    ipcMain.on("selectContentFolder", async () => {
      try {
        if (!mainWindow) return;
        const dialogReturnValue = await dialog.showOpenDialog(mainWindow, {
          properties: ["openDirectory", "showHiddenFiles"],
        });

        if (!dialogReturnValue.canceled) {
          const contentFolderPath = dialogReturnValue.filePaths[0];
          appData.gamesToGameFolderPaths[appData.currentGame].contentFolder = contentFolderPath;
          mainWindow?.webContents.send("setContentFolder", contentFolderPath);
          refreshModsIfFoldersValid();
        }
      } catch (e) {
        console.log(e);
      }
    });

    ipcMain.on("selectWarhammer3Folder", async () => {
      try {
        if (!mainWindow) return;
        const dialogReturnValue = await dialog.showOpenDialog(mainWindow, {
          properties: ["openDirectory", "showHiddenFiles"],
        });

        if (!dialogReturnValue.canceled) {
          const wh3FolderPath = dialogReturnValue.filePaths[0];
          appData.gamesToGameFolderPaths[appData.currentGame].gamePath = wh3FolderPath;
          appData.gamesToGameFolderPaths[appData.currentGame].dataFolder = nodePath.join(
            wh3FolderPath,
            "/data/"
          );
          mainWindow?.webContents.send("setWarhammer3Folder", wh3FolderPath);

          if (appData.gamesToGameFolderPaths[appData.currentGame].gamePath == undefined) return;

          const calculatedContentPath = nodePath.join(
            appData.gamesToGameFolderPaths[appData.currentGame].gamePath as string,
            "..",
            "..",
            "workshop",
            "content",
            gameToSteamId[appData.currentGame]
          );
          if (fs.existsSync(calculatedContentPath)) {
            appData.gamesToGameFolderPaths[appData.currentGame].contentFolder = calculatedContentPath;
            mainWindow?.webContents.send("setContentFolder", calculatedContentPath);
          }
          refreshModsIfFoldersValid();
        }
      } catch (e) {
        console.log(e);
      }
    });

    ipcMain.handle("getSteamCollectionName", async (event, steamCollectionURL: string) => {
      try {
        console.log("getting steamCollectionURL name:", steamCollectionURL);
        const res = await fetch(steamCollectionURL);
        const cheerioObj = cheerio.load(await res.text());
        const collectionTitle = cheerioObj(".collectionHeaderContent").find(".workshopItemTitle").text();
        console.log("collection title:", collectionTitle);
        return collectionTitle;
      } catch (e) {
        console.log(e);
      }

      return "";
    });

    ipcMain.handle("translate", (event, translationId: string, options?: Record<string, string | number>) => {
      return i18n.t(translationId, options);
    });

    ipcMain.handle(
      "translateAll",
      (event, translationIdsWithOptions: Record<string, Record<string, string | number>>) => {
        const translated: Record<string, string> = {};
        for (const id of Object.keys(translationIdsWithOptions)) {
          translated[id] = i18n.t(id, translationIdsWithOptions[id]);
        }
        return translated;
      }
    );

    ipcMain.handle("translateAllStatic", (event, translationIds: Record<string, string | number>) => {
      const translated: Record<string, string> = {};
      for (const id of Object.keys(translationIds)) {
        translated[id] = i18n.t(id);
      }
      return translated;
    });

    ipcMain.on("getCompatData", async (event, mods: Mod[]) => {
      console.log("SET PACK COLLISIONS");

      await readMods(mods, false, true);
      await readModsByPath(
        appData.vanillaPacks.map((pack) => pack.path),
        false,
        true
      );
      // if (pathsToUse) {
      mainWindow?.webContents.send(
        "setPackCollisions",
        getCompatData(
          appData.packsData.filter(
            (pack) =>
              mods.some((mod) => mod.path == pack.path) ||
              appData.vanillaPacks.some((vanillaPack) => vanillaPack.path == pack.path)
          ),
          (currentIndex, maxIndex, firstPackName, secondPackName, type) => {
            mainWindow?.webContents.send("setPackCollisionsCheckProgress", {
              currentIndex,
              maxIndex,
              firstPackName,
              secondPackName,
              type,
            } as PackCollisionsCheckProgressData);
          }
        )
      );
      // } else {
      //   mainWindow?.webContents.send("setPackCollisions", getCompatData(appData.packsData));
      // }
      // mainWindow?.webContents.send("setPackCollisions", {
      // packFileCollisions: appData.compatData.packFileCollisions,
      // packTableCollisions: appData.compatData.packTableCollisions,
      // } as PackCollisions);
    });

    ipcMain.on("copyToData", async (event, modPathsToCopy?: string[]) => {
      if (!appData.gamesToGameFolderPaths[appData.currentGame].gamePath) return;
      console.log("copyToData: modPathsToCopy:", modPathsToCopy);
      const mods = await getMods(log);
      let withoutDataMods = mods.filter((mod) => !mod.isInData);
      if (modPathsToCopy) {
        withoutDataMods = withoutDataMods.filter((mod) =>
          modPathsToCopy.some((modPathToCopy) => modPathToCopy == mod.path)
        );
      }
      const copyPromises = withoutDataMods.map((mod) => {
        mainWindow?.webContents.send(
          "handleLog",
          `COPYING ${mod.path} to ${appData.gamesToGameFolderPaths[appData.currentGame].gamePath}\\data\\${
            mod.name
          }`
        );

        if (!appData.gamesToGameFolderPaths[appData.currentGame].gamePath)
          throw new Error("game path not set");
        return fs.copyFileSync(
          mod.path,
          nodePath.join(
            appData.gamesToGameFolderPaths[appData.currentGame].gamePath as string,
            "/data/",
            mod.name
          )
        );
      });

      await Promise.allSettled(copyPromises);
      // getAllMods();
    });

    ipcMain.on("copyToDataAsSymbolicLink", async (event, modPathsToCopy?: string[]) => {
      console.log("copyToDataAsSymbolicLink modPathsToCopy:", modPathsToCopy);
      const mods = await getMods(log);
      let withoutDataMods = mods.filter((mod) => !mod.isInData);
      if (modPathsToCopy) {
        withoutDataMods = withoutDataMods.filter((mod) =>
          modPathsToCopy.some((modPathToCopy) => modPathToCopy == mod.path)
        );
      }

      const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
      if (!gamePath) return;
      const pathsOfNewSymLinks = withoutDataMods.map((mod) =>
        nodePath.join(gamePath ?? "", "/data/", mod.name)
      );
      const copyPromises = withoutDataMods.map((mod) => {
        mainWindow?.webContents.send(
          "handleLog",
          `CREATING SYMLINK of ${mod.path} to ${gamePath}\\data\\${mod.name}`
        );

        if (!gamePath) throw new Error("game path not set");
        return fsExtra.symlink(mod.path, nodePath.join(gamePath, "/data/", mod.name));
      });

      await Promise.allSettled(copyPromises);

      // should be tracked automatically by the data watcher, but chokidar can choke on symlinks here
      for (const pathsOfNewSymLink of pathsOfNewSymLinks) {
        onNewPackFound(pathsOfNewSymLink);
      }
      // getAllMods();
    });

    ipcMain.on("cleanData", async () => {
      const mods = await getMods(log);
      mods.forEach((mod) => {
        if (mod.isInData) mainWindow?.webContents.send("handleLog", `is in data ${mod.name}`);
      });
      const modsInBothPlaces = mods.filter(
        (mod) => mod.isInData && mods.find((modSecond) => !modSecond.isInData && modSecond.name === mod.name)
      );
      const deletePromises = modsInBothPlaces.map((mod) => {
        mainWindow?.webContents.send("handleLog", `DELETING ${mod.path}`);

        return fs.unlinkSync(mod.path);
      });

      await Promise.allSettled(deletePromises);
      // getAllMods();
    });

    ipcMain.on("cleanSymbolicLinksInData", async () => {
      const mods = await getMods(log);
      const symLinksToDelete = mods.filter((mod) => mod.isInData && mod.isSymbolicLink);
      console.log("symLinksToDelete", symLinksToDelete);
      const deletePromises = symLinksToDelete.map((mod) => {
        mainWindow?.webContents.send("handleLog", `DELETING SYMLINK ${mod.path}`);

        return fs.unlinkSync(mod.path);
      });

      await Promise.allSettled(deletePromises);

      // should be tracked automatically by the data watcher, but chokidar can choke on symlinks here
      for (const deletedSymLink of symLinksToDelete) {
        onPackDeleted(deletedSymLink.path);
      }
      // getAllMods();
    });

    ipcMain.on("saveConfig", (event, data: AppState) => {
      console.log("saveConfig");
      const enabledMods = data.currentPreset.mods.filter(
        (iterMod) => iterMod.isEnabled || data.alwaysEnabledMods.find((mod) => mod.name === iterMod.name)
      );
      appData.enabledMods = enabledMods;
      const hiddenAndEnabledMods = data.hiddenMods.filter((iterMod) =>
        enabledMods.find((mod) => mod.name === iterMod.name)
      );
      mainWindow?.setTitle(
        `WH3 Mod Manager v${version}: ${enabledMods.length} mods enabled` +
          (hiddenAndEnabledMods.length > 0 ? ` (${hiddenAndEnabledMods.length} of those hidden)` : "") +
          ` for ${gameToGameName[appData.currentGame]}`
      );
      // console.log(
      //   "BEFORE saveconfig",
      //   appData.gameToCurrentPreset["wh2"]?.mods[0].name,
      //   appData.gameToCurrentPreset["wh3"]?.mods[0].name,
      //   data.currentGame,
      //   data.currentPreset.mods[0].name
      // );

      writeAppConfig(data);
    });

    const dbTableToString = (dbTable: DBTable) => {
      return `db\\${dbTable.dbName}\\${dbTable.dbSubname}`;
    };

    const getPackData = async (packPath: string, table?: DBTable, getLocs?: boolean) => {
      console.log(`getPackData ${packPath}`);
      const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
      if (table) console.log("GETTING TABLE ", table.dbName, table.dbSubname);
      for (const vanillaPackData of gameToVanillaPacksData[appData.currentGame]) {
        const baseVanillaPackName = vanillaPackData.name;
        if (packPath == baseVanillaPackName || nodePath.basename(packPath) == baseVanillaPackName) {
          if (!dataFolder) {
            console.log("WAIT FOR DATAFOLDER TO BE SET");
            await new Promise((resolve) => setTimeout(resolve, 1000));
            console.log("DONE WAITING FOR DATAFOLDER");
            getPackData(packPath, table, getLocs);
            return;
          }
          if (packPath == baseVanillaPackName) {
            console.log("data folder is", dataFolder);
            packPath = nodePath.join(dataFolder as string, baseVanillaPackName);
          }
        }
      }
      console.log("CURRENTLY READING:", appData.currentlyReadingModPaths);

      console.log("before join", dataFolder, packPath);
      if (!packPath.includes("\\")) {
        // if we provided pack name instead of pack path as argument
        if (!dataFolder) {
          console.log("WAIT FOR DATAFOLDER TO BE SET");
          await new Promise((resolve) => setTimeout(resolve, 1000));
          console.log("DONE WAITING FOR DATAFOLDER");
          getPackData(packPath, table, getLocs);
          return;
        }
        packPath = nodePath.join(dataFolder as string, packPath);
      }
      const packData = appData.packsData.find((pack) => pack.path === packPath);

      // console.log("packsdata is", appData.packsData);
      // console.log("to read:", packPath);
      // console.log("found packs for reading:", packData);

      console.log(
        "getPackData:",
        appData.currentlyReadingModPaths.every((path) => path != packPath)
      );
      console.log("getPackData:", !packData);
      console.log("getPackData:", table);
      if (packData && table)
        console.log(
          "getPackData:",
          packData.packedFiles
            .filter((packedFile) => packedFile.schemaFields)
            .every((packedFile) => packedFile.name != dbTableToString(table))
        );
      if (
        appData.currentlyReadingModPaths.every((path) => path != packPath) &&
        (!packData ||
          (table &&
            packData.packedFiles
              .filter((packedFile) => packedFile.schemaFields)
              .every((packedFile) => packedFile.name != dbTableToString(table))))
      ) {
        appData.currentlyReadingModPaths.push(packPath);
        console.log(`READING ${packPath}`);
        const newPack = await readPack(
          packPath,
          table && { tablesToRead: [dbTableToString(table)], readLocs: getLocs }
        );
        appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
          (path) => path != packPath
        );
        if (appData.packsData.every((pack) => pack.path != packPath)) {
          console.log("APPENDING packsData", packPath);
          appendPacksData(newPack);
        }

        const toSend = [getPackViewData(newPack, table, getLocs)];
        mainWindow?.webContents.send("setPacksData", toSend);
        viewerWindow?.webContents.send("setPacksData", toSend);
        if (!isViewerReady) {
          console.log("VIEWER NOT READY, QUEUEING");
          queuedViewerData = toSend;
        }
      } else {
        if (appData.currentlyReadingModPaths.some((path) => path == packPath)) {
          console.log("WAIT");
          await new Promise((resolve) => setTimeout(resolve, 1000));
          console.log("DONE WAITING");
          getPackData(packPath, table, getLocs);
          return;
        }
        const packData = appData.packsData.find((pack) => pack.path === packPath);

        if (packData) {
          const toSend = [getPackViewData(packData, table, getLocs)];

          mainWindow?.webContents.send("setPacksData", toSend);
          viewerWindow?.webContents.send("setPacksData", toSend);
          if (!isViewerReady) {
            console.log("VIEWER NOT READY, QUEUEING");
            queuedViewerData = toSend;
          }
        }
      }
    };

    ipcMain.on("getPackData", async (event, packPath: string, table?: DBTable) => {
      getPackData(packPath, table);
    });

    ipcMain.on("getPackDataWithLocs", async (event, packPath: string, table?: DBTable) => {
      getPackData(packPath, table, true);
    });

    ipcMain.on("requestOpenModInViewer", (event, modPath: string) => {
      for (const vanillaPackData of gameToVanillaPacksData[appData.currentGame]) {
        const baseVanillaPackName = vanillaPackData.name;
        if (modPath == baseVanillaPackName) {
          modPath = nodePath.join(
            appData.gamesToGameFolderPaths[appData.currentGame].dataFolder as string,
            baseVanillaPackName
          );
        }
      }
      console.log("ON requestOpenModInViewer", modPath);
      viewerWindow?.webContents.send("openModInViewer", modPath);
      viewerWindow?.setTitle(`WH3 Mod Manager v${version}: viewing ${nodePath.basename(modPath)}`);
      getPackData(modPath);
      if (viewerWindow) {
        viewerWindow.focus();
      } else {
        createViewerWindow();
      }
    });

    ipcMain.on("requestLanguageChange", async (event, language: string) => {
      await i18n.changeLanguage(language);
      mainWindow?.webContents.send("setCurrentLanguage", language);
    });

    const setCurrentGame = async (newGame: SupportedGames) => {
      try {
        appData.currentGame = newGame;
        if (!appData.gamesToGameFolderPaths[appData.currentGame]) {
          await getFolderPaths(log);
        }
        const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
        const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
        const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
        if (!gamePath || !contentFolder || !dataFolder) {
          await getFolderPaths(log);
        }

        appData.packsData = [];
        appData.saveSetupDone = false;
        await getAllMods();
      } finally {
        const contentFolder = appData.gamesToGameFolderPaths[appData.currentGame].contentFolder;
        const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
        console.log("SENDING setAppFolderPaths", gamePath, contentFolder);
        mainWindow?.webContents.send("setAppFolderPaths", {
          gamePath: gamePath || "",
          contentFolder: contentFolder || "",
        } as GameFolderPaths);
      }
    };

    ipcMain.on("requestGameChange", async (event, game: SupportedGames, appState: AppState) => {
      // console.log("game before change is", appData.currentGame, "to", game);

      appData.gameToCurrentPreset[appState.currentGame] = appState.currentPreset;
      appData.gameToPresets[appState.currentGame] = appState.presets;

      await setCurrentGame(game);
      const currentPreset = appData.gameToCurrentPreset[game];
      // console.log("SETTING GAME IN INDEX", game, currentPreset?.mods[0].name);
      const presets = appData.gameToPresets[game];
      mainWindow?.webContents.send("setCurrentGame", game, currentPreset, presets);
    });

    const readModsByPath = async (
      modPaths: string[],
      skipParsingTables = true,
      skipCollisionCheck = true
    ) => {
      console.log("readModsByPath:", modPaths);
      console.log("readModsByPath skipParsingTables:", skipParsingTables);
      console.log("readModsByPath skipCollisionCheck:", skipCollisionCheck);
      if (!skipParsingTables) {
        appData.packsData = appData.packsData.filter(
          (pack) => !modPaths.some((modPath) => modPath == pack.path)
        );
      }
      for (const modPath of modPaths) {
        if (
          appData.currentlyReadingModPaths.every((path) => path != modPath) &&
          appData.packsData.every((pack) => pack.path != modPath)
        ) {
          console.log("READING " + modPath);
          appData.currentlyReadingModPaths.push(modPath);
          mainWindow?.webContents.send("setCurrentlyReadingMod", modPath);
          const newPack = await readPack(modPath, {
            skipParsingTables,
          });
          mainWindow?.webContents.send("setLastModThatWasRead", modPath);
          appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
            (path) => path != modPath
          );
          if (appData.packsData.every((pack) => pack.path != modPath)) {
            appendPacksData(newPack);
          }
          if (!skipCollisionCheck) {
            appendCollisions(newPack);
          }
        }
      }
      if (!skipCollisionCheck) {
        mainWindow?.webContents.send("setPackCollisions", {
          packFileCollisions: appData.compatData.packFileCollisions,
          packTableCollisions: appData.compatData.packTableCollisions,
        } as PackCollisions);
      }
    };

    const readMods = async (mods: Mod[], skipParsingTables = true, skipCollisionCheck = true) => {
      if (!skipParsingTables) {
        appData.packsData = appData.packsData.filter((pack) => !mods.some((mod) => mod.path == pack.path));
      }
      for (const mod of mods) {
        if (
          appData.currentlyReadingModPaths.every((path) => path != mod.path) &&
          appData.packsData.every((pack) => pack.path != mod.path)
        ) {
          console.log("READING " + mod.name);
          appData.currentlyReadingModPaths.push(mod.path);
          if (!skipParsingTables) mainWindow?.webContents.send("setCurrentlyReadingMod", mod.name);
          const newPack = await readPack(mod.path, {
            skipParsingTables,
          });
          if (!skipParsingTables) mainWindow?.webContents.send("setLastModThatWasRead", mod.name);
          appData.currentlyReadingModPaths = appData.currentlyReadingModPaths.filter(
            (path) => path != mod.path
          );
          if (appData.packsData.every((pack) => pack.path != mod.path)) {
            appendPacksData(newPack, mod);
          }
          if (!skipCollisionCheck) {
            appendCollisions(newPack);
          }
        }
      }

      if (!skipCollisionCheck) {
        mainWindow?.webContents.send("setPackCollisions", {
          packFileCollisions: appData.compatData.packFileCollisions,
          packTableCollisions: appData.compatData.packTableCollisions,
        } as PackCollisions);
      }
    };

    let lastReadModsReceived = [];
    ipcMain.on("readMods", (event, mods: Mod[], skipCollisionCheck = true) => {
      if (lastReadModsReceived.length != mods.length) {
        console.log(
          "READ MODS RECEIVED",
          mods.map((mod) => mod.name)
        );
        lastReadModsReceived = [...mods];
      }
      readMods(mods, skipCollisionCheck, skipCollisionCheck);
    });

    ipcMain.removeHandler("getUpdateData");
    ipcMain.handle("getUpdateData", async () => {
      if (isDev) return;

      let modUpdatedExists = { updateExists: false } as ModUpdateExists;

      const isAvailable = await updateAvailable("Shazbot/WH3-Mod-Manager", version);
      if (!isAvailable) return modUpdatedExists;

      await fetch(`https://api.github.com/repos/Shazbot/WH3-Mod-Manager/releases/latest`)
        .then((res) => res.json())
        .then((body) => {
          body.assets.forEach((asset: { content_type: string; browser_download_url: string }) => {
            mainWindow?.webContents.send("handleLog", asset.content_type == "application/x-zip-compressed");
            if (asset.content_type === "application/x-zip-compressed") {
              modUpdatedExists = {
                updateExists: true,
                downloadURL: asset.browser_download_url,
              } as ModUpdateExists;
            }
          });

          if (body.html_url) modUpdatedExists.releaseNotesURL = body.html_url;
        })
        .catch();

      return modUpdatedExists;
    });

    ipcMain.on("sendApiExists", async () => {
      mainWindow?.webContents.send("handleLog", "API now exists");
      mainWindow?.webContents.send("setIsDev", isDev);
      mainWindow?.webContents.send("setStartArgs", appData.startArgs);
      mainWindow?.webContents.send("setIsAdmin", appData.isAdmin);

      // if (isDev) mainWindow?.webContents.openDevTools();

      try {
        const localesPath = isDev ? "./locales/" : "./resources/app/.webpack/main/locales";
        const availableLocalizations = (await fs.readdirSync(localesPath, { withFileTypes: true }))
          .filter((dirent) => dirent.isDirectory())
          .map((dirent) => dirent.name);

        mainWindow?.webContents.send("setAvailableLanguages", availableLocalizations);
        // eslint-disable-next-line no-empty
      } catch (e) {}

      if (!checkWH3RunningInterval) {
        checkWH3RunningInterval = setInterval(async () => {
          const processes = await psList();
          const isWH3Running = processes.some(
            (process) => process.name == gameToProcessName[appData.currentGame]
          );
          if (appData.isWH3Running != isWH3Running) {
            appData.isWH3Running = isWH3Running;
            mainWindow?.webContents.send("setIsWH3Running", appData.isWH3Running);
          }
        }, 500);
      }
    });
  };

  const createViewerWindow = () => {
    if (viewerWindow) return;

    const viewerWindowState = windowStateKeeper({
      file: "viewer_window.json",
      defaultWidth: 1280,
      defaultHeight: 900,
    });

    viewerWindow = new BrowserWindow({
      x: viewerWindowState.x,
      y: viewerWindowState.y,
      width: viewerWindowState.width,
      height: viewerWindowState.height,
      autoHideMenuBar: true,
      titleBarStyle: "hidden",
      titleBarOverlay: {
        color: "#374151",
        symbolColor: "#9ca3af",
        height: 28,
      },
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
        preload: VIEWER_PRELOAD_WEBPACK_ENTRY,
      },
      title: "WH3 Mod Manager Mod Viewer",
      icon: "./assets/modmanager.ico",
    });

    viewerWindowState.manage(viewerWindow);

    viewerWindow.loadURL(VIEWER_WEBPACK_ENTRY);

    viewerWindow.on("page-title-updated", (evt) => {
      evt.preventDefault();
    });

    viewerWindow.on("closed", () => {
      viewerWindow = undefined;
      isViewerReady = false;
    });
  };

  app.on("second-instance", () => {
    // Someone tried to run a second instance, we should focus our window.
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on("ready", createWindow);

  app.whenReady().then(() => {
    installExtension(REACT_DEVELOPER_TOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));

    installExtension(REDUX_DEVTOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log("An error occurred: ", err));
  });

  // Quit when all windows are closed, except on macOS. There, it's common
  // for applications and their menu bar to stay active until the user quits
  // explicitly with Cmd + Q.
  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });

  process.on("unhandledRejection", (err) => {
    console.log(err);
  });
  process.on("uncaughtException", (err) => {
    console.log(err);
  });

  const sendQueuedDataToViewer = async () => {
    if (!isViewerReady) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      sendQueuedDataToViewer();
      return;
    }

    console.log("SENDING QUEUED DATA TO VIEWER");
    viewerWindow?.webContents.send("setPacksData", queuedViewerData);
    viewerWindow?.webContents.send("openModInViewer", queuedViewerData[0]?.packPath);
    if (queuedViewerData[0]?.packPath)
      viewerWindow?.setTitle(
        `WH3 Mod Manager v${version}: viewing ${nodePath.basename(queuedViewerData[0]?.packPath)}`
      );
    viewerWindow?.focus();
    queuedViewerData = [];
  };

  ipcMain.on("viewerIsReady", () => {
    console.log("VIEWER IS NOW READY");
    isViewerReady = true;

    // console.log("QUEUED DATA IS ", queuedViewerData);
    if (queuedViewerData.length > 0) {
      sendQueuedDataToViewer();
    }
  });

  ipcMain.on("openFolderInExplorer", (event, path: string) => {
    shell.showItemInFolder(path);
  });

  ipcMain.on("openInSteam", (event, url: string) => {
    exec(`start steam://openurl/${url}`);
  });

  ipcMain.on("openPack", (event, path: string) => {
    shell.openPath(path);
  });
  ipcMain.on("putPathInClipboard", (event, path: string) => {
    clipboard.writeText(path);
  });
  ipcMain.on("updateMod", async (event, mod: Mod, contentMod: Mod) => {
    const uploadFolderName = contentMod.workshopId;
    const uploadFolderPath = nodePath.join(nodePath.dirname(mod.path), "whmm_uploads_" + uploadFolderName);

    await fs.rmSync(uploadFolderPath, { recursive: true, force: true });
    await fs.mkdirSync(uploadFolderPath, { recursive: true });

    await fs.linkSync(mod.path, nodePath.join(uploadFolderPath, mod.name));
    await fs.linkSync(mod.imgPath, nodePath.join(uploadFolderPath, nodePath.basename(mod.imgPath)));

    const child = fork(
      nodePath.join(__dirname, "sub.js"),
      [gameToSteamId[appData.currentGame], "update", contentMod.workshopId, uploadFolderPath],
      {}
    );
    child.on("message", (folderPath: string) => {
      console.log("child says delete");
      fs.rmSync(folderPath, { recursive: true, force: true });
    });
  });
  ipcMain.on("fakeUpdatePack", async (event, mod: Mod) => {
    try {
      const backupFolderPath = nodePath.join(nodePath.dirname(mod.path), "whmm_backups");
      const backupFilePath = nodePath.join(
        backupFolderPath,
        nodePath.parse(mod.name).name +
          "-" +
          format(new Date(), "dd-MM-yyyy-HH-mm") +
          nodePath.parse(mod.name).ext
      );
      const uploadFilePath = nodePath.join(
        backupFolderPath,
        nodePath.parse(mod.name).name +
          "-NEW-" +
          format(new Date(), "dd-MM-yyyy-HH-mm") +
          nodePath.parse(mod.name).ext
      );

      await fs.mkdirSync(backupFolderPath, { recursive: true });
      await fs.copyFileSync(mod.path, backupFilePath);
      await addFakeUpdate(mod.path, uploadFilePath);

      const command = `cd /d "${nodePath.dirname(mod.path)}" && del "${nodePath.basename(
        mod.path
      )}" && move /y "whmm_backups\\${nodePath.basename(uploadFilePath)}" "${nodePath.basename(mod.path)}"`;
      console.log(command);

      exec(command);
    } catch (e) {
      console.log(e);
    }
  });

  ipcMain.on("makePackBackup", async (event, mod: Mod) => {
    try {
      const uploadFolderPath = nodePath.join(nodePath.dirname(mod.path), "whmm_backups");
      const backupFilePath = nodePath.join(
        uploadFolderPath,
        nodePath.parse(mod.name).name +
          "-" +
          format(new Date(), "dd-MM-yyyy-HH-mm") +
          nodePath.parse(mod.name).ext
      );
      await fs.mkdirSync(uploadFolderPath, { recursive: true });
      await fs.copyFileSync(mod.path, backupFilePath);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on(
    "importSteamCollection",
    async (
      event,
      steamCollectionURL: string,
      isImmediateImport: boolean,
      doDisableOtherMods: boolean,
      isLoadOrdered: boolean,
      doCreatePreset: boolean,
      presetName: string,
      isPresetLoadOrdered: boolean
    ) => {
      try {
        console.log("getting steamCollectionURL:", steamCollectionURL);
        const res = await fetch(steamCollectionURL);
        const cheerioObj = cheerio.load(await res.text());
        const collectionTitle = cheerioObj(".collectionHeaderContent").find(".workshopItemTitle").text();
        console.log("collection title:", collectionTitle);
        const modIds = cheerioObj(".collectionItem")
          .map((_, elem) => elem.attribs["id"].replace("sharedfile_", ""))
          .toArray();
        if (!collectionTitle) return;
        mainWindow?.webContents.send("importSteamCollectionResponse", {
          name: collectionTitle,
          modIds,
          isImmediateImport,
          doDisableOtherMods,
          isLoadOrdered,
          doCreatePreset,
          presetName,
          isPresetLoadOrdered,
        } as ImportSteamCollection);

        console.log(modIds);
      } catch (e) {
        console.log(e);
      }
    }
  );
  ipcMain.on("forceModDownload", async (event, mod: Mod) => {
    try {
      fork(
        nodePath.join(__dirname, "sub.js"),
        [gameToSteamId[appData.currentGame], "download", mod.workshopId],
        {}
      );
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("reMerge", async (event, mod: Mod, modsToMerge: Mod[]) => {
    try {
      mergeMods(modsToMerge, mod.path);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("deletePack", async (event, mod: Mod) => {
    try {
      await fsExtra.remove(mod.path);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("forceDownloadMods", async (event, modIds: string[]) => {
    try {
      fork(
        nodePath.join(__dirname, "sub.js"),
        [gameToSteamId[appData.currentGame], "download", modIds.join(";")],
        {}
      );
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("unsubscribeToMod", async (event, mod: Mod) => {
    try {
      fork(
        nodePath.join(__dirname, "sub.js"),
        [gameToSteamId[appData.currentGame], "unsubscribe", mod.workshopId],
        {}
      );
      await fsExtra.remove(mod.path);
    } catch (e) {
      console.log(e);
    }
  });
  ipcMain.on("mergeMods", async (event, mods: Mod[]) => {
    try {
      mergeMods(mods).then((targetPath) => {
        mainWindow?.webContents.send("createdMergedPack", targetPath);
      });
    } catch (e) {
      console.log(e);
    }
  });

  const subscribeToMods = async (ids: string[]) => {
    fork(nodePath.join(__dirname, "sub.js"), [gameToSteamId[appData.currentGame], "sub", ids.join(";")], {});
    await new Promise((resolve) => setTimeout(resolve, 1000));
    fork(
      nodePath.join(__dirname, "sub.js"),
      [gameToSteamId[appData.currentGame], "download", ids.join(";")],
      {}
    );
    await new Promise((resolve) => setTimeout(resolve, 1000));
    fork(nodePath.join(__dirname, "sub.js"), [gameToSteamId[appData.currentGame], "justRun"], {});
    await new Promise((resolve) => setTimeout(resolve, 500));
    mainWindow?.webContents.send("subscribedToMods", ids);
  };

  ipcMain.on("subscribeToMods", async (event, ids: string[]) => {
    await subscribeToMods(ids);
  });

  ipcMain.on("exportModsToClipboard", async (event, mods: Mod[]) => {
    const sortedMods = sortByNameAndLoadOrder(mods);
    const enabledMods = sortedMods.filter((mod) => mod.isEnabled);

    const exportedMods = enabledMods
      .filter((mod) => !isNaN(Number(mod.workshopId)) && !isNaN(parseFloat(mod.workshopId)))
      .map((mod) => mod.workshopId + (mod.loadOrder != null ? `;${mod.loadOrder}` : ""))
      .join("|");
    clipboard.writeText(exportedMods);
  });

  ipcMain.on("exportModNamesToClipboard", async (event, mods: Mod[]) => {
    const sortedMods = sortByNameAndLoadOrder(mods);
    const enabledMods = sortedMods.filter((mod) => mod.isEnabled);

    const exportedMods = enabledMods
      .filter((mod) => mod.humanName != "")
      .map((mod) => mod.humanName)
      .join("\n");
    clipboard.writeText(exportedMods);
  });

  ipcMain.on("createSteamCollection", async (event, mods: Mod[]) => {
    const workshopIDs = mods.map((mod) => mod.workshopId);
    const scriptWithIDs = steamCollectionScript.replace(
      "var workshopIds = []",
      "var workshopIds = [" + workshopIDs.map((wID) => `"${wID}"`).join(",") + "]"
    );
    clipboard.writeText(scriptWithIDs);
  });

  const getDBsForGameStartOptions = async (mods: Mod[], startGameOptions: StartGameOptions) => {
    const tablesToRead: string[] = [];
    if (startGameOptions.isMakeUnitsGeneralsEnabled) {
      tablesToRead.push("db\\units_custom_battle_permissions_tables\\");
    }

    if (tablesToRead.length == 0) return;

    mainWindow?.webContents.send("addToast", {
      type: "info",
      messages: ["Processing mods..."],
      startTime: Date.now(),
    } as Toast);

    for (const mod of mods) {
      const existingPack = appData.packsData.find((pack) => pack.path == mod.path);
      let needsReRead = false;
      if (existingPack) {
        const lastChangedLocal = (await fsExtra.statSync(mod.path)).mtimeMs;
        if (lastChangedLocal != existingPack.lastChangedLocal) {
          needsReRead = true;
          appData.packsData = appData.packsData.filter((pack) => pack.path != mod.path);
        }
      }
      console.log("READING FOR GAME START " + mod.name);
      let newPack: Pack | null = null;
      if (existingPack && !needsReRead) {
        console.log("existingPack.readTables", existingPack.readTables);
        console.log("tablesToRead", tablesToRead);
        if (existingPack.readTables === "all") {
          console.log("don't need to read tables for", existingPack.name, "all tables in pack are parsed");
          continue;
        }
        if (
          tablesToRead.every((tableToRead) =>
            (existingPack.readTables as string[]).some((iterTableName) => iterTableName == tableToRead)
          )
        ) {
          console.log("don't need to read tables for", existingPack.name, tablesToRead, "are parsed");
          continue;
        }

        console.log("reading from existing pack");
        newPack = await readFromExistingPack(existingPack, {
          tablesToRead,
        });
      } else {
        console.log("reading from new pack");
        newPack = await readPack(mod.path, {
          tablesToRead,
        });
      }
      appendPacksData(newPack, mod);
    }
  };

  ipcMain.on(
    "startGame",
    async (
      event,
      mods: Mod[],
      areModsPresorted: boolean,
      startGameOptions: StartGameOptions,
      saveName?: string
    ) => {
      console.log("before start:");
      for (const pack of appData.packsData) {
        console.log(pack.name, pack.readTables);
      }
      try {
        for (const supportedGameOption of supportedGameOptions) {
          if (!gameToSupportedGameOptions[appData.currentGame].includes(supportedGameOption)) {
            const startGameOption = supportedGameOptionToStartGameOption[supportedGameOption];
            console.log(`setting startGameOption ${startGameOption} to false`);
            startGameOptions[startGameOption] = false;
          }
        }

        const gamePath = appData.gamesToGameFolderPaths[appData.currentGame].gamePath;
        const dataFolder = appData.gamesToGameFolderPaths[appData.currentGame].dataFolder;
        if (!gamePath) return;

        const appDataPath = app.getPath("userData");
        const myModsPath = nodePath.join(gamePath, "my_mods.txt");
        const usedModsPath = nodePath.join(gamePath, "used_mods.txt");

        const sortedMods = sortByNameAndLoadOrder(mods);
        const enabledMods = sortedMods.filter((mod) => mod.isEnabled);

        const linuxBit = process.platform === "linux" ? "Z:" : "";
        const vanillaPacks = [];
        for (const vanillaPackData of gameToVanillaPacksData[appData.currentGame]) {
          const baseVanillaPackName = vanillaPackData.name;
          const dataMod: Mod = {
            humanName: "",
            name: baseVanillaPackName,
            path: nodePath.join(dataFolder as string, baseVanillaPackName),
            imgPath: "",
            workshopId: "",
            isEnabled: true,
            modDirectory: `${dataFolder}`,
            isInData: true,
            lastChanged: undefined,
            loadOrder: undefined,
            author: "",
            isDeleted: false,
            isMovie: false,
            size: 0,
            isSymbolicLink: false,
          };
          vanillaPacks.push(dataMod);
        }

        let extraEnabledMods = "";
        if (
          startGameOptions.isMakeUnitsGeneralsEnabled ||
          startGameOptions.isScriptLoggingEnabled ||
          startGameOptions.isSkipIntroMoviesEnabled ||
          startGameOptions.isAutoStartCustomBattleEnabled
        ) {
          log("making temp dir");
          await fs.mkdirSync(nodePath.join(appDataPath, "tempPacks"), { recursive: true });

          log("getting start game dbs");
          await getDBsForGameStartOptions(enabledMods.concat(vanillaPacks), startGameOptions);

          console.log("before start:");
          for (const pack of appData.packsData) {
            console.log(pack.name, pack.readTables);
          }

          const tempPackName = "!!!!out.pack";
          const tempPackPath = nodePath.join(appDataPath, "tempPacks", tempPackName);
          log("writing start game pack");

          let failedWriting = true;
          for (let i = 0; i < 10; i++) {
            try {
              tryOpenFile(tempPackPath);
              await writePack(
                appData.packsData,
                tempPackPath,
                enabledMods.concat(vanillaPacks),
                startGameOptions
              );
              failedWriting = false;
              break;
            } catch (e) {
              await new Promise((resolve) => setTimeout(resolve, 500));
              if (i == 0) {
                mainWindow?.webContents.send("addToast", {
                  type: "info",
                  messages: ["Game still closing, retrying..."],
                  startTime: Date.now(),
                } as Toast);
              }
            }
          }

          if (!failedWriting) {
            log("done writing temp pack");
            extraEnabledMods =
              `\nadd_working_directory "${linuxBit + nodePath.join(appDataPath, "tempPacks")}";` +
              `\nmod "${tempPackName}";`;
          } else {
            log("gave up trying to write temp pack");
          }
        }

        const modPathsInsideMergedMods = enabledMods
          .filter((mod) => mod.mergedModsData)
          .map((mod) => (mod.mergedModsData as MergedModsData[]).map((mod) => mod.path))
          .flatMap((paths) => paths);

        let enabledModsWithoutMergedInMods = enabledMods.filter(
          (mod) => !modPathsInsideMergedMods.some((path) => path == mod.path)
        );

        const enabledModsWithOverwrites = enabledModsWithoutMergedInMods.filter(
          (iterMod) => startGameOptions.packDataOverwrites[iterMod.path]
        );
        enabledModsWithoutMergedInMods = enabledModsWithoutMergedInMods.filter(
          (iterMod) => !startGameOptions.packDataOverwrites[iterMod.path]
        );
        console.log("enabledModsWithOverwrites:", enabledModsWithOverwrites);

        if (enabledModsWithOverwrites.length > 0) {
          const mergedDirPath = nodePath.join(
            appData.gamesToGameFolderPaths[appData.currentGame].gamePath as string,
            "/whmm_overwrites/"
          );

          if (!fsExtra.existsSync(mergedDirPath)) {
            exec(`mkdir "${mergedDirPath}"`);
            await new Promise((resolve) => {
              setTimeout(resolve, 100);
            });
          }

          extraEnabledMods += `\nadd_working_directory "${linuxBit + mergedDirPath}";`;

          for (const pack of enabledModsWithOverwrites) {
            await createOverwritePack(
              pack.path,
              nodePath.join(mergedDirPath, pack.name),
              startGameOptions.packDataOverwrites[pack.path]
            );

            extraEnabledMods += `\nmod "${pack.name}";`;
          }
        }

        const text =
          enabledModsWithoutMergedInMods
            .filter(
              (mod) =>
                nodePath.relative(
                  appData.gamesToGameFolderPaths[appData.currentGame].dataFolder as string,
                  mod.modDirectory
                ) != ""
            )
            .map((mod) => `add_working_directory "${linuxBit + mod.modDirectory}";`)
            .concat(enabledModsWithoutMergedInMods.map((mod) => `mod "${mod.name}";`))
            .join("\n") + extraEnabledMods;

        let fileNameWithModList = "used_mods.txt";
        try {
          log("writing used_mods.txt");
          await fs.writeFileSync(usedModsPath, text);
        } catch (e) {
          log("failed writing to used_mods.txt, trying to use my_mods.txt");
          fileNameWithModList = "my_mods.txt";
          await fs.writeFileSync(myModsPath, text);
        }
        const batPath = nodePath.join(appDataPath, "game.bat");
        let batData = `start /d "${appData.gamesToGameFolderPaths[appData.currentGame].gamePath}" ${
          gameToProcessName[appData.currentGame]
        }`;
        if (saveName) {
          batData += ` game_startup_mode campaign_load "${saveName}" ;`;
        }
        // file with the list of mods for the game to use, used_mods.txt or my_mods.txt
        batData += ` ${fileNameWithModList};`;

        mainWindow?.webContents.send("handleLog", "starting game:");
        mainWindow?.webContents.send("handleLog", batData);

        await fs.writeFileSync(batPath, batData);
        execFile(batPath);

        if (startGameOptions.isClosedOnPlay) {
          await new Promise((resolve) => {
            setTimeout(resolve, 5000);
          });

          app.exit();
        }
      } catch (e) {
        console.log(e);
      }
    }
  );
}
